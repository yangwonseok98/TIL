# 완전 검색 & 그리디

## INDEX

> **INDEX**
> 
> - 반복(Iteration)과 재귀(Recursion)
> - 완전 검색 기법
> - 순열
> - 부분 집합
> - 조합
> - 탐욕 알고리즘
> - 활동 선택 문제
> - Baby-gin

---

## 학습 목표

> **학습 목표**
> 
> - 재귀적 알고리즘의 특성을 이해하고 이를 구현하기 위한 재귀 호출에 대해 학습한다.
> - 완전 검색의 개념을 이해하고 완전 검색을 통한 문제 해결 방법에 대해 학습한다,
> - 조합적 문제(Combinatorial Problems)에 대한 완전 검색 방법에 대해 이해한다.
>     - 순열, 조합, 부분 집합을 생성하는 알고리즘을 학습한다.
> - 탐욕 알고리즘 기법의 개념과 주요 특성을 이해한다.

---

## 반복(Iteration)과 재귀(Recursion)

> **반복(Iteration)과 재귀(Recursion)**
> 
> - 반복과 재귀는 유사한 작업을 수행할 수 있다.
> - 반복은 수행하는 작업이 완료될 때 까지 계속 반복
>     - 루프 (for, while 구조)
> - 재귀는 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법
>     - 하나의 큰 문제를 해결할 수 있는(해결하기 쉬운) 더 작은 문제로 쪼개고 결과들을 결합한다.
>     - 재귀 함수로 구현
> 
> - 반복 구조
>     - 초기화
>         - 반복되는 명령문을 실행하기 전에(한번만) 조건 검사에 사용할 변수의 초기 값 설정
>     - 조건 검사(check control expression)
>     - 반복할 명령문 실행 (action)
>     - 업데이트(loop update)
>         - 무한 루프(infinite loop)가 되지 않게 조건이 거짓(false)이 되게 한다.
>     
>     ![Untitled](완전%20검색%20%26%20그리디%20136a59f7e8de4495a777c524cbf23531/Untitled.png)
>     
> 
> - 반복을 이용한 선택 정렬
>     
>     ```python
>     def SelectionSort(A):
>         n = len(A)
>         for i in range(0, n-1):
>             idx = i
>             for j in range(i+1, n):
>                 if A[j] < A[idx]:
>                     idx = j
>             A[idx], A[i] = A[i], A[idx]
>     
>     list1 = [9, 4, 2, 1, 3, 7, 6]
>     SelectionSort(list1)
>     print(list1)
>     ```
>     
> - 재귀적 알고리즘
>     - 재귀적 정의는 두 부분으로 나뉜다.
>     - 하나 또는 그 이상의 기본 경우 (basis case or rule)
>         - 집합에 포함되어 있는 원소로 induction을 생성하기 위한 시드(seed)역할
>     - 하나 또는 그 이상의 유도된 경우 (inductive case or rule)
>         - 새로운 집합의 원소를 생성하기 위해 결합 되어지는 방법
>     
> - 재귀 함수(recursive function)
>     - 함수 내부에서 직접 혹은 간접적으로 자기 자신을 호출하는 함수
>     - 일반적으로 재귀적 정의를 이용해서 재귀 함수를 구현한다.
>     - 따라서, 기본 부분(basis part)와 유도 부분(inductive part)로 구성된다.
>     - 재귀적 프로그램을 작성하는 것은 반복 구조에 비해 간결하고 이해하기 쉽다.
>         - 그러나, 재귀에 대해 익숙하지 않은 개발자들은 재귀적 프로그램이 어렵다고 느낀다.
>     - 함수 호출을 프로그램 메모리 구조에서 스택을 사용한다. 따라서 재귀 호출은 반복 적인 스택의 사용을 의미하며 메모리 및 속도에서 성능 저하가 발생한다,
> 
> - 팩토리얼 재귀 함수
>     - 재귀적 정의
>         
>         ```
>         Basis rule:
>         	N <= 1 경우, n = 1
>         Inductive rule:
>         	N > 1, n! = n * (n-1)!
>         ```
>         
>     - $n!$ 에 대한 재귀함수
>         
>         ```python
>         def fact(n):
>         	if n <= 1:
>         		return 1
>         	else:
>         		return n * fact(n-1)
>         ```
>         
> 
> - 팩토리얼 재귀 함수의 호출
>     
>     ```python
>     def fact(n):
>     	if n <= 1:
>     		return 1
>     	else:
>     		return n * fact(n-1)
>     ```
>     
>     ![Untitled](완전%20검색%20%26%20그리디%20136a59f7e8de4495a777c524cbf23531/Untitled%201.png)
>     
> 
> - 반복과 재귀
>     - 해결할 문제를 고려해서 반복이나 재귀의 방법을 선택
>     - 재귀는 문제 해결을 위한 알고리즘 설계가 간단하고 자연스럽다.
>         - 추상 자료형(List, Tree 등)의 알고리즘은 재귀적 구현이 간단하고 자연스러운 경우가 많다.
>     - 일반적으로, 재귀적 알고리즘은 반복(Iteration) 알고리즘보다 더 많은 메모리와 연산을 필요로 한다.
>     - **입력 값 n이 커질수록 재귀 알고리즘은 반복에 비해 비효율적일 수 있다.**
> 
> - 반복과 재귀의 비교
>     
>     ![Untitled](완전%20검색%20%26%20그리디%20136a59f7e8de4495a777c524cbf23531/Untitled%202.png)
>     
> 
> - $2^k$ 연산에 대한 재귀와 반복
>     - 재귀 Recursion
>     
>     ```python
>     def Power_of_2(k):
>         if k == 0:
>             return 1
>         else:
>             return 2 * Power_of_2(k-1)
>     ```
>     
>     - 반복 Iteration
>     
>     ```python
>     def Power_of_2(k):
>         i = 0
>         power = 1
>         while i < k:
>             power = power * 2
>             i = i + 1
>         return power
>     ```
>     
> - 선택 정렬 함수(Selection Sort)를 재귀적 알고리즘으로 작성해 보시오.
>     
>     ```python
>     def selection_sort(A, i_f):
>         min_idx = i_f
>         n = len(A)
>         if n - i_f > 1:
>             for i in range(i_f, n):
>                 if A[min_idx] > A[i]:
>                     min_idx = i
>             A[min_idx], A[i_f] = A[i_f], A[min_idx]
>             selection_sort(A, i_f+1)
>     
>     list1 = [9, 4, 2, 1, 3, 7, 6]
>     selection_sort(list1, 0)
>     print(list1)
>     ```
>     

---

## 완전 검색 기법

> **완전 검색 기법**
> 
> - 문제 제시 : Baby-gin Game
>     - 설명
>         - 0~9 사이의 숫자 카드에서 임의의 카드 6장을 뽑았을 때, 3장의 카드가 연속적인 번호를 갖는 경우를 run이라 하고, 3장의 카드가 동일한 번호를 갖는 경우를 triplet 이라고 한다.
>         - 그리고, 6장의 카드가 run과 triplet로만 구성된 경우를 baby-gin으로  부른다.
>         - 6자리의 숫자를 입력 받아 baby-gin 여부를 판단하는 프로그램을 작성하라.
>     - 입력 예
>         - 667767은 두 개의 triplet 이므로 baby-gin이다.
>         - 054060은 한 개의 run과 한 개의 triplet이므로 역시 baby-gin이다.
>         - 101123은 한 개의 triplet가 존재하나, 023이 run이 아니므로 baby-gin이 아니다.
>     - 6자리의 숫자를 입력 받아 어떻게 Baby-gin 여부를 찾을 것인가?
> 
> - 고지식한 방법(brute-force)
>     - brute-force는 문제를 해결하기 위한 간단하고 쉬운 접근 법이다.
>         - “Just-do-it”
>         - force의 의미는 사람(지능) 보다는 컴퓨터의 force를 의미한다.
>         - brute-force 방법은 대부분의 문제에 적용 가능하다
>         - 상대적으로 빠른 시간에 문제 해결(알고리즘 설계)을 할 수 있다.
>         - 문제에 포함된 자료(요소, 인스턴스)의 크기가 작다면 유용하다.
>         - 학술적 또는 교육적 목적을 위해 알고리즘의 효율성을 판단하기 위한 척도로 사용된다.
> 
> - Brute-force 탐색 (sequential search)
>     - 자료들의 리스트에서 키 값을 찾기 위해 첫 번째 자료부터 비교하면서 진행한다.
>     - 결과
>         - 탐색 성공
>         - 탐색 실패
>     
>     ```python
>     def sequential_search(A, k):
>         idx = 0
>         n = len(A)
>         while idx < n:
>             if A[idx] == k:
>                 break
>             idx += 1
>         if idx < n:
>             return idx
>         else:
>             return -1
>     
>     list1 = [9, 4, 2, 1, 3, 7, 6]
>     print(sequential_search(list1, 5))
>     print(sequential_search(list1, 3))
>     ```
>     
> - 완전 검색으로 시작하라
>     - 모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 작다.
>         - 완전 검색은 입력의 크기를 작게 해서 간편하고 빠르게 답을 구하는 프로그램을 작성한다.
>     - 이를 기반으로 그리디 기법이나 동적 계획법을 이용해서 효율적인 알고리즘을 찾을 수 있다.
>     - 검정 등에서 주어진 문제를 풀 때, **우선 완전 검색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직**하다.
>     
> - 완전 검색을 통한 Baby-gin 접근
>     - 고려할 수 있는 모든 경우의 수 생성하기
>         - 6개의 숫자로 만들 수 있는 모든 숫자 나열(중복 포함)
>         - 예) 입력으로 {2, 3, 5, 7, 7, 7}을 받았을 경우, 아래와 같이 순열을 생성할 수 있다.
>             
>             ![Untitled](완전%20검색%20%26%20그리디%20136a59f7e8de4495a777c524cbf23531/Untitled%203.png)
>             
>     - 해답 테스트하기
>         - 앞의 3자리와 뒤의 3자리를 잘라, run와 triplet 여부를 테스트하고 최종적으로 baby-gin을 판단한다.
>         - 예)
>         
>         ![Untitled](완전%20검색%20%26%20그리디%20136a59f7e8de4495a777c524cbf23531/Untitled%204.png)
>         
> 
> - 완전 검색
>     - 많은 종류의 문제들이 특정 조건을 만족하는 경우나 요소를 찾는 것이다.
>     - 또한, 이들은 전형적으로 순열(permutation), 조합(combination), 그리고 부분 집합(subsets)과 같은 조합적 문제들(Combinatorial Problems) 과 연관된다.
>     - 완전 검색은 조합적 문제에 대한 brute-force 방법이다.

---

## 순열

> **순열**
> 
> - 문제 제시 : 여행사 BIG sale!
>     
>     ![Untitled](완전%20검색%20%26%20그리디%20136a59f7e8de4495a777c524cbf23531/Untitled%205.png)
>     
> 
> - 순열(Permutation)
>     - 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
>     - 서로 다른 n개 중 r개를 택하는 순열은 아래와 같이 표현한다.
>         - $_{n}P_{r}$
>     - 그리고 $_{n}P_{r}$은 다음과 같은 식이 성립한다.
>         - $_{n}P_{r} = n\times (n-1)\times (n-2)\times ... \times(n-r+1)$
>     - $_{n}P_{n} = n!$ 이라고 표기하며 Factorial이라 부른다.
>         - $n! = n \times (n-1) \times (n-2) \times ... \times 2\times 1$
>     
>     - 다수의 알고리즘 문제들은 순서화 된 요소들의 집합에서 최선의 방법을 찾는 것과 관련 있다.
>         - 예) TSP(Traveling Salesman Problem)
>     - N 개의 요소들에 대해서 $n!$ 개의 순열 들이 존재한다.
>         - $12! = 479,001,600$
>         - $n>12$ 인 경우, 시간 복잡도가 폭발적으로 증가한다.
>     
>     - 단순하게 순열을 생성하는 방법
>         - 예) {1, 2, 3}을 포함하는 모든 순열을 생성하는 함수
>             - 동일한 숫자가 포함되지 않았을 때, 각 자리 수 별로 loop을 이용해 아래와 같이 구현할 수 있다.
>                 
>                 ```python
>                 for i1 in range(1, 4):
>                     for i2 in range(1, 4):
>                         if i2 != i1:
>                             for i3 in range(1, 4):
>                                 if i3 != i1 and i3 != i2:
>                                     print(i1, i2, i3)
>                 ```
>                 
> 
> - 순열 생성 방법
>     - 사전적 순서(Lexicographic-Order)
>         - {1, 2, 3}, n = 3 인 경우 다음과 같이 생성된다.
>         - [1 2 3], [1 3 2], [2 1 3], [2 3 1], [3 1 2], [3 2 1]
>     - 최소 변경을 통한 방법(Minimum-exchange requirement)
>         - 각각의 순열들은 이전 상태에서 단지 두 개의 요소들 교환을 통해 생성
>         - [1 2 3], [3 2 1], [2 3 1], [2 1 3], [3 1 2], [1 3 2]
> 
> - 최소한의 변경(Minimum-exchange requirement)을 통해 다음 순열을 생성하는 방법
>     - 1950년대의 교회의 종소리 패턴하고 유사
>     - Johnson-Trotter 알고리즘
>         
>         ![Untitled](완전%20검색%20%26%20그리디%20136a59f7e8de4495a777c524cbf23531/Untitled%206.png)
>         
> - 재귀 호출을 통한 순열 생성
>     
>     ```python
>     def perm(i, k):
>         if i == k:
>             print(list1)
>         else:
>             for j in range(i, k):
>                 list1[i], list1[j] = list1[j], list1[i]
>                 perm(i+1, k)
>                 list1[i], list1[j] = list1[j], list1[i]
>     
>     list1 = [1, 2, 3, 4]
>     perm(0, len(list1))
>     ```
>     

---

### [참고]

> **[참고]**
> 
> - 1, 2, 3으로 구성된 순열
>     
>     ![Untitled](완전%20검색%20%26%20그리디%20136a59f7e8de4495a777c524cbf23531/Untitled%207.png)
>     
>     ![Untitled](완전%20검색%20%26%20그리디%20136a59f7e8de4495a777c524cbf23531/Untitled%208.png)
>     
>     ```python
>     def perm(i, k):
>         if i == k:
>             print(p)
>         else:
>             for j in range(0, k):
>                 if not used[j]:
>                     p[i] = arr[j]
>                     used[j] = True
>                     perm(i+1, k)
>                     used[j] = False
>     
>     arr = [1, 2, 3, 4]
>     used = [False for i in range(4)]
>     p = [None for i in range(3)]
>     perm(0, 3)
>     ```
>     

---

### <연습 문제 2>

> **<연습 문제 2>**
> 
> - 6자리 숫자에 대해서 완전 검색을 적용해서 Baby-gin을 검사해보시오.
> - 입력 예
>     
>     124783
>     
>     667767
>     
>     054060
>     
>     101123
>     
>     ```python
>     def is_run(list1):
>         res = True
>         for i in range(1, 3):
>             if list1[i-1]+1 != list1[i]:
>                 res = False
>                 break
>         return res
>     
>     def is_triplet(list1):
>         return list1[0] == list1[1] and list1[0] == list1[2]
>     
>     arr = list(map(int, input()))
>     arr.sort()
>     arr1 = arr[:3]
>     arr2 = arr[3:]
>     is_baby_gin = (is_run(arr1) or is_triplet(arr1)) and (is_run(arr2) or is_triplet(arr2))
>     print(is_baby_gin)
>     ```
>     

---

## 부분 집합

> **부분 집합**
> 
> - 집합에 포함된 원소들을 선택하는 것이다.
> - 다수의 중요 알고리즘들이 원소들의 그룹에서 최적의 부분 집합을 찾는 것이다.
>     - 예) 배낭 짐 싸기(knapsack)
> - N 개의 원소를 포함한 집합
>     - 자기 자신과 공 집합을 포함한 모든 부분 집합(power set)의 개수는 $2^n$ 개
>     - 원소의 수가 증가하면 부분 집합의 개수는 지수 적으로 증가
> 
> - 단순하게 모든 부분 집합을 생성하는 방법
>     - 4개 원소를 포함한 집합에 대한 power set 구하기
>         
>         ```python
>         bit = [0, 0, 0, 0]
>         for i1 in range(2):
>             bit[0] = i1
>             for i2 in range(2):
>                 bit[1] = i2
>                 for i3 in range(2):
>                     bit[2] = i3
>                     for i4 in range(2):
>                         bit[3] = i4
>                         print(bit)
>         ```
>         
> 
> - 바이너리 카운팅을 통한 사전적 순서(Lexicographic Order)
>     - 부분집합을 생성하기 위한 가장 자연스러운 방법이다.
>     - 바이너리 카운팅(Binary Counting)은 사전적 순서로 생성하기 위한 가장 간단한 방법이다.
>     
> - 바이너리 카운팅(Binary Counting)
>     - 원소 수에 해당하는 N개의 비트열을 이용한다.
>     - n번째 비트값이 1이면 n번째 원소가 포함되었음을 의미한다.
>         
>         ![Untitled](완전%20검색%20%26%20그리디%20136a59f7e8de4495a777c524cbf23531/Untitled%209.png)
>         
> 
> - 바이너리 카운팅을 통한 부분집합 생성 코드 예
>     
>     ```python
>     arr = [3, 6, 7, 1, 5, 4]
>     n = len(arr)
>     
>     for i in range(0, (1<<n)):
>         for j in range(0, n):
>             if i & (1 << j):
>                 print("%d"%arr[j], end='')
>         print()
>     ```
>     

---

## 조합

> **조합**
> 
> - 서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것을 조합(Combination)이라고 부른다.
> - 조합의 수식
>     - $_nC_{r} = \frac{n!}{(n-r)!\times r!}$, $(n\geq r)$
>     - $_nC_{r} = _{n-1}C_{r-1} + _{n-1}C_{r}$
>     - $_nC_{0} = 1$
> 
> - 재귀 호출을 이용한 조합 생성 알고리즘
>     
>     ```python
>     def comb(n, r):
>         if r == 0:
>             print(tr)
>         elif n < r:
>             return
>         else:
>             tr[r-1] = an[n-1]
>             comb(n-1, r-1)
>             comb(n-1, r)
>     
>     an = [1, 2, 3, 4, 5, 6]
>     tr = [None for i in range(3)]
>     comb(6, 3)
>     ```
>     
>     ![Untitled](완전%20검색%20%26%20그리디%20136a59f7e8de4495a777c524cbf23531/Untitled%2010.png)
>     

---

### [참고]

> **[참고]**
> 
> - 10개의 원소 중 3개를 고르는 조합
>     - i < j < k 라고 하면,
>         
>         ```python
>         arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>         
>         for i in range(0, 8):
>             for j in range(i+1, 9):
>                 for k in range(j+1, 10):
>                     print(arr[i], arr[j], arr[k])
>         ```
>         
> 
> - n개에서 r개를 고르는 조합 (재귀)
>     
>     ```python
>     def nCr(n, r, s):
>         if r == 0:
>             print(*comb)
>         else:
>             for i in range(s, n-r+1):
>                 comb[r-1] = A[i]
>                 nCr(n, r-1, i+1)
>     
>     A = [i for i in range(10)]
>     comb = [None for i in range(3)]
>     nCr(10, 3, 0)
>     ```
>     

---

### <연습 문제 3>

> **<연습 문제 3>**
> 
> - 부분집합 합 문제 구현하기
>     - 아래의 10개의 정수 집합에 대한 모든 부분 집합 중 원소의 합이 0이 되는 부분 집합을 모두 출력하시오.
>     - 예) {-1, 3, -9, 6, 7, -6, 1, 5, 4, -2}
>     
>     ```python
>     arr = [-1, 3, -9, 6, 7, -6, 1, 5, 4, -2]
>     n = len(arr)
>     
>     for i in range(1<<n):
>         tmp = []
>         for j in range(n):
>             if i & (1 << j):
>                 tmp.append(arr[j])
>         if sum(tmp) == 0:
>             print(tmp)
>     ```
>     

---

## 탐욕 알고리즘

> **탐욕 알고리즘**
> 
> - 문제 제시 : 거스름돈 줄이기
>     - 손님이 지불한 금액에서 물건값을 제한 차액(거스름돈)을 지불하는 문제를 생각해보자.
>     - “어떻게 하면 손님에게 거스름돈으로 주는 지폐와 동전의 개수를 최소한으로 줄일 수 있을까?”
> 
> - 탐욕 알고리즘은 최적해를 구하는 데 사용되는 근시안적인 방법
> - 일반적으로, 머리속에서 떠오르는 생각을 검증 없이 바로 구현하면 Greedy 접근이 된다.
> - 여러 경우 중 하나를 선택 할 때 마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달한다.
> - 각 선택 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, **그것이 최적이라는 보장은 없다.**
> 
> - 일단, 한 번 선택된 것은 반복하지 않는다. 이런 특성 때문에 대부분의 탐욕 알고리즘들은 단순하며, 또한 제한적인 문제들에 적용된다.
> - 최적화 문제(optimization)란 가능한 해들 중에서 가장 좋은(최대 또는 최소)해를 찾는 문제이다.
> 
> - 탐욕 알고리즘의 동작 과정
>     1. 해 선택 : 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분 해 집합(Solution Set)에 추가한다.
>     2. 실행 가능성 검사 : 새로운 부분 해 집합이 실행 가능한 지를 확인한다. 곧, 문제의 제약 조건을 위반하지 않는 지를 검사한다.
>     3. 해 검사 : 새로운 부분 해 집합이 문제의 해가 되는지를 확인한다. 아직 전체 문제의 해가 완성되지 않았다면 1의 해 선택부터 다시 시작한다.
>     
>     - 탐욕 기법을 적용한 거스름돈 줄이기
>         1. 해 선택 : 여기에서는 멀리 내다볼 것 없이 가장 좋은 해를 선택한다. 단위가 큰 동전으로만 거스름돈을 만들면 동전의 개수가 줄어드므로 현재 고를 수 있는 가장 단위가 큰 동전을 하나 골라 거스름돈에 추가한다.
>         2. 실행 가능성 검사 : 거스름돈이 손님에게 내 드려야 할 액수를 초과하는지 확인한다. 초과한다면 마지막에 추가한 동전을 거스름돈에서 빼고, 1로 돌아가서 현재보다 한 단계 작은 단위의 동전을 추가한다.
>         3. 해 검사 : 거스름돈 문제의 해는 당연히 거스름돈이 손님에게 내 드려야 하는 액수와 일치하는 샘이다. 더 드려도, 덜 드려도 안되기 때문에 거스름돈을 확인해서 액수에 모자라면 다시 1로 돌아가서 거스름돈에 추가할 동전을 고른다.
>     
>     - 최적 해를 반드시 구한다는 보장이 없다.
>         
>         ![Untitled](완전%20검색%20%26%20그리디%20136a59f7e8de4495a777c524cbf23531/Untitled%2011.png)
>         
>     
> - 배낭 짐싸기(Knapsack)
>     - 도둑은 부자들의 값진 물건들을 훔치기 위해 보관 창고에 침입하였다.
>     - 도둑은 훔친 물건을 배낭에 담아 올 계획이다. 배낭은 담을 수 있는 물건의 총 무게(W)가 정해져 있다.
>     - 창고에는 여러 개(n개)의 물건들이 있고 각각의 물건에는 무게와 값이 정해져 있다.
>     - 경비원들에게 발각되기 전에 배낭이 수용할 수 있는 무게를 초과하지 않으면서, 값이 최대가 되는 물건들을 담아야 한다.
>         
>         ![Untitled](완전%20검색%20%26%20그리디%20136a59f7e8de4495a777c524cbf23531/Untitled%2012.png)
>         
>     
>     - Knapsack 문제의 정형적 정의
>         - $s = \{ item_1, item_2,...,item_n\}$, 물건들의 집합
>         - $w_i$ : $item_i$ 의 무게, $P_i$ : $item_i$ 의 값
>         - $W$ : 배낭이 수용가능 한 총 무게
>         
>         - 문제 정의
>             
>             $\Sigma_{item_i \in A} w_i \leq W$ 를 만족하면서 $\Sigma_{item_i \in A}P_i$ 가 최대가 되도록 $A \subseteq S$ 가 되는 $A$ 를 결정하는 문제
>             
>     
>     - Knapsack 문제 유형
>         - 0-1 Knapsack
>             - 배낭에 물건을 통째로 담아야 하는 문제
>             - 물건을 쪼갤 수 없는 경우
>         - Fractional Knapsack
>             - 물건을 부분적으로 담는 것이 허용되는 문제.
>             - 물건을 쪼갤 수 있는 경우
> 
> - 0-1 Knapsack 에 대한 완전 검색 방법
>     - 완전 검색으로 물건들의 집합 S에 대한 모든 부분 집합을 구한다.
>     - 부분 집합의 총 무게가 W를 초과하는 집합들은 버리고, 나머지 집합에서 총 값이 가장 큰 집합을 선택할 수 있다.
>     - 물건의 개수가 증가하면 시간 복잡도가 지수적으로 증가한다.
>         - 크기 $n$인 부분 집합의 수 : $2^n$
> 
> - 0-1 Knapsack 에 대한 탐욕적 방법1
>     
>     ![Untitled](완전%20검색%20%26%20그리디%20136a59f7e8de4495a777c524cbf23531/Untitled%2013.png)
>     
>     - 값이 비싼 물건부터 채운다.
>     - W = 30kg
>     
>     - 탐욕적 방법의 결과
>         - (물건 1), 25kg, 10만원
>     - 최적 해
>         - (물건 2, 물건 3), 20kg, 14만원
>     - 최적이 아니다.
> 
> - 0-1 Knapsack 에 대한 탐욕적 방법2
>     
>     ![Untitled](완전%20검색%20%26%20그리디%20136a59f7e8de4495a777c524cbf23531/Untitled%2014.png)
>     
>     - 무게가 가벼운 물건부터 채운다..
>     - W = 30kg
>     
>     - 탐욕적 방법의 결과
>         - (물건 2, 물건 3), 14만원
>     - 최적 해
>         - (물건 1), 15만원
>     - 역시 최적 해를 구할 수 없다.
> 
> - 0-1 Knapsack 에 대한 탐욕적 방법3
>     
>     ![Untitled](완전%20검색%20%26%20그리디%20136a59f7e8de4495a777c524cbf23531/Untitled%2015.png)
>     
>     - 무게가 가벼운 물건부터 채운다..
>     - W = 30kg
>     
>     - 탐욕적 방법의 결과
>         - (물건 1, 물건 3), 190만원
>     - 최적 해
>         - (물건 2, 물건 3), 200만원
>     - 역시, 탐욕적 방법으로 최적해를 구하기 어렵다.
> 
> - Fractional Knapsack 문제
>     - 물건의 일부를 잘라서 담을 수 있다.
>         
>         ![Untitled](완전%20검색%20%26%20그리디%20136a59f7e8de4495a777c524cbf23531/Untitled%2016.png)
>         
>     - 탐욕적인 방법
>         - (물건 1 + 물건 3 + 물건 2의 절반), 30kg, 220만원

---

## 활동 선택 문제

> **활동 선택 문제**
> 
> - 회의실 배정하기
>     - 김대리는 소프트웨어 개발팀들의 회의실 사용 신청을 처리하는 업무를 한다. 이번 주 금요일에 사용 가능한 회의실은 하나만 존재하고 다수의 회의가 신청된 상태이다.
>     - 회의는 시작 시간과 종료 시간이 있으며, 회의 시간이 겹치는 회의들은 동시에 열릴 수 없다.
>     - 가능한 많은 회의가 열리기 위해서는 회의들을 어떻게 배정해야 할까?
>     - 입력 예
>         - 회의 개수
>         - (시작 시간, 종료 시간)
>             
>             10
>             
>             1 4 1 6 6 10 5 7 3 8 5 9 3 5 8 11 2 13 12 14
>             
>     
>     - 시작 시간과 종료 시간 $(s_i, f_i)$이 있는 $n$개의 활동들의 집합 $A = \{A_1, A_2,...,A_n\}$, $1 \leq i \leq n$에서 서로 겹치지 않는(non-overlapping) 최대갯수의 활동들의 집합 $S$를 구하는 문제
>     - 양립 가능한 활동들의 크기가 최대가 되는 $S_{0, n+1}$ 의 부분집합을 선택하는 문제
>         - 종료 시간 순으로 활동들을 정렬한다.
>         - $S_{0, n+1}$는 $a_0$의 종료 시간부터 $a_{n+1}$의 시작 시간 사이에 포함된 활동들
>         - $S_{0, n+1} = \{a_{1},a_{2},a_{3},a_{4},a_{5},a_{6},a_{7},a_{8},a_{9},a_{10}\} = S$
>             
>             ![Untitled](완전%20검색%20%26%20그리디%20136a59f7e8de4495a777c524cbf23531/Untitled%2017.png)
>             
>     
>     - 탐욕 기법의 적용
>         - 공 집합이 아닌 하위 문제(subproblem) $S_{i, j}$ 가 있고 $S_{i, j}$ 에 속한 활동 $a_m$은 종료 시간이 가장 빠른 활동이다.
>         - 그렇다면
>             1. 하위 문제(subproblem) $S_{i, j}$에서 종료 시간이 가장 빠른 활동 $a_m$을 선택한다.
>             2. $S_{i, m}$ 은 공 집합 이므로, $a_m$을 선택하면 공 집합이 아닌 하위 문제 $S_{m, j}$가 남는다.
>             3. 1, 2 과정을 반복한다.
>         - $S_{i, j}$를 풀기 위해
>             1. 종료 시간이 가장 빠른 $a_m$ 선택
>             2. $S_{i, j} = \{a_m\} \cup S_{m,j}$ 의 해 집합
>                 
>                 
>                 $S_{0, 11}$ 에 대해, $a_1$ 선택하고, $S_{1, 11}$을 푼다.
>                 
>                 $S_{1, 11}$ 에 대해, $a_1$ 선택하고, $S_{4, 11}$을 푼다.
>                 
>                 $S_{4, 11}$ 에 대해, $a_8$ 선택하고, $S_{8, 11}$을 푼다.
>                 
>     
>     - 탐욕 기법을 적용한 반복 알고리즘
>         - 종료 시간이 빠른 순서로 활동들을 정렬한다.
>         - 첫 번째 활동 ($A_1$)을 선택한다.
>         - 선택한 활동 ($A_1$)의 종료시간보다 빠른 시작 시간을 가지는 활동을 모두 제거한다.
>         - 남은 활동들에 대해 앞의 과정을 반복한다.
>         
>         - 예제) 종료 시간으로 정렬된 10개의 회의 들
>             
>             ![Untitled](완전%20검색%20%26%20그리디%20136a59f7e8de4495a777c524cbf23531/Untitled%2018.png)
>             
>             ![Untitled](완전%20검색%20%26%20그리디%20136a59f7e8de4495a777c524cbf23531/Untitled%2019.png)
>             
>             ![Untitled](완전%20검색%20%26%20그리디%20136a59f7e8de4495a777c524cbf23531/Untitled%2020.png)
>             
>             ![Untitled](완전%20검색%20%26%20그리디%20136a59f7e8de4495a777c524cbf23531/Untitled%2021.png)
>             
> 
> - 탐욕 알고리즘의 필수 요소
>     - 탐욕적 선택 속성(greedy choice property)
>         - 탐욕적 선택은 최적해로 갈 수 있음을 보여라.
>             - 즉, 탐욕적 선택은 항상 안전하다.
>     - 최적 부분 구조(optimal substructure property)
>         - 최적화 문제를 정형화하라.
>             - 하나의 선택을 하면 풀어야 할 하나의 하위 문제가 남는다.
>     - **[원 문제의 최적 해 = 탐욕적 선택 + 하위 문제의 최적 해]** 임을 증명하라.
>     
>     - 탐욕 기법과 동적 계획법의 비교
>         
>         ![Untitled](완전%20검색%20%26%20그리디%20136a59f7e8de4495a777c524cbf23531/Untitled%2022.png)
>         
>     
>     - 대표적인 탐욕 기법의 알고리즘들
>         
>         ![Untitled](완전%20검색%20%26%20그리디%20136a59f7e8de4495a777c524cbf23531/Untitled%2023.png)
>         

---

## Baby-gin

> **Baby-gin**
> 
> - 탐욕 기법을 통한 Baby-gin 문제 해결
>     - 탐욕 기법을 통한 Baby-gin 문제 해결
>     - 완전 검색 아닌 방법으로 풀어보자.
>         - 6개의 숫자는 6자리 정수 값으로 입력된다.
>         - counts 배열의 각 원소를 체크하여 run과 triplet 및 baby-gin 여부를 판단한다.
>     - 풀이
>         
>         ![Untitled](완전%20검색%20%26%20그리디%20136a59f7e8de4495a777c524cbf23531/Untitled%2024.png)
>         

---
