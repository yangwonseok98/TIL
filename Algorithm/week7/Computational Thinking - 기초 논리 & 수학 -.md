# Computational Thinking - 기초 논리 & 수학 -

---

## INDEX

> **INDEX**
> 
> 1. 서론 - 프로그래밍과 논리/수학
> 2. 논리와 증명
> 3. 수와 표현
> 4. 집합과 조합론
> 5. 기초 수식
> 6. 재귀
> 7. 동적 프로그래밍

---

## 서문

> **서문**
> 
> - 당신이 Problem Solving 문제를 봤는데 어떻게 풀어야 할지 전혀 감이 오지 않는다.
> - Dijkstra 알고리즘 아무리 봐도, “될 것 같기는 한데” 이유는 모르겠다.
> - 도구나 라이브러리는 잘 쓰는데 프로그램 처음부터 짜려면 막막하다.
> - 어떻게 프로그램을 짜면 더 빠른지, 더 느린지 전혀 감이 없다.
> - $\log n$을 본 적이 없거나, 본 적이 있는데 무슨 뜻이라고 한 마디로 설명하지는 못한다. 혹은, $\log n$의 밑이 10이나 $e$라고 알고 있다.
> - Problem Solving 자료를 보고 시간을 들여도 발전이 없다.
> 
> - 위의 상황 중 하나라도 일치하는 상황이 있다면
>     - Problem Solving을 본격적으로 공부할 준비가 안된 것일 수 있다.
>     - “왜 이해가 안되는 것인가?”
> - 필요한 것은, 아마도
>     - 논리적으로 정확하게 확인하는 과정에 대한 연습이 없어서 이다.
>     - 되는 것 같다는 기분이나 “공식을 외우는 것” 말고 정확하게 확인해 본 적이 있는가?
>     - 프로그램을 짜기 시작하기 전에, 정확한 결과가 나올 것인지, 얼마나 빠르게 돌아갈 것인지 미리 알 수 있는가?
>     - 확인이 안된 상태에서 프로그램을 짜기 시작하면, 결과가 정확할지, 얼마나 빠를 지 예측할 수 없고, 제대로 된 결과가 나오지 않으면 고치는 것이 어렵고 무작정 여러가지를 시도해 볼 수 밖에 없다.
>     - 정확히 확인하는 훈련이 되어 있지 않으면, 단순 작업 이상의 코드를 작성하기 어렵고, 다른 사람의 코드를 고치는 것도 매우 어렵다.
> 
> - 정확하게 확인하는 과정을 수 많은 세월 동안 정리해 둔 것이 “증명” 기법이다.
> - 증명 기법은 딱딱한 것이 아닌 기발한 아이디어들의 집합이고 “이해하면 재미있는 그림” 과 같다.
> - 이 과정에서 쉬운 문제들을 보고 정확하게 확인하는 것을 연습해 보자.
>     
>     **”어떤 전공도 상식선에서 이해되는 분야는 없다.”**
>     

---

## 1. 서론 - 프로그래밍과 논리/수학

> **서론 - 프로그래밍과 논리/수학**
> 
> - 프로그래밍의 어려운 점 두 가지
>     - 프로그래밍 언어 문법과 라이브러리 사용
>     - 논리(Hard Logic)
> - 문법과 라이브러리
>     - 많이 알려진 어려운 점
>     - 위 프로그램이 무엇을 하는 것인지 처음 보는 사람은 알 수 없음
> 
> - 능숙해 지기 위해 많은 훈련이 필요하지만, 이 과정의 중요 목표는 아님
> - 프로그래밍을 최초로 배울 때 약간의 어려움이 있지만 훈련에 비례하여 실력이 느는 경향이 있음
> - 일반 상식으로 원래 알고 있는 것이 아니기 때문에 훈련의 필요성에 대한 반감이 없음
> 
> - 논리 (Hard Logic)
>     - Hard vs Soft Logic
>         - 카드 문제
>             - 사실 : 모든 카드의 한쪽에는 알파벳이, 다른 쪽에는 숫자가 써 있음
>                 
>                 ![Untitled](Computational%20Thinking%20-%20%E1%84%80%E1%85%B5%E1%84%8E%E1%85%A9%20%E1%84%82%E1%85%A9%E1%86%AB%E1%84%85%E1%85%B5%20&%20%E1%84%89%E1%85%AE%E1%84%92%E1%85%A1%E1%86%A8%20-%2012644fe8df284319a3ec05bb4aad6df5/Untitled.png)
>                 
>             
>             - 주장 : 만약 한쪽이 D 이면 반대쪽은 3
>             - 주장이 사실인지 확인하기 위해 다음 카드들 중 반드시 뒤집어 보아야 하는 것은 몇 개 이고 어느 것인가?
>             - 답 : [D] 와 [7]
>                 - [D] → [3], ~[3] → ~[D]
>             - [D]를 뒤집어 보아야 한다는 것은 누구나 알아 냄
>             - [3]을 뒤집어 보아야 한다고 말하는 경우가 많이 있음
>             - **중요 : [3] 뒤에 [D]가 있든 없든 주장이 사실인지 여부에 영향이 없음**
>             - [7]을 뒤집어 볼 필요가 없다고 말하는 경우도 많음
>             - **중요 : [7] 뒤에 [D]가 있으면 주장이 성립하지 않게 됨**
>         
>         - 맥주 집 문제
>             - 규칙 : 20세 이하인 사람은 맥주를 마실 수 없음
>             - 나이 혹은 마시고 있는 것을 표시한 다음 4명 중 확인이 필요한 사람은 몇 명이고 누구인가?
>                 
>                 ![Untitled](Computational%20Thinking%20-%20%E1%84%80%E1%85%B5%E1%84%8E%E1%85%A9%20%E1%84%82%E1%85%A9%E1%86%AB%E1%84%85%E1%85%B5%20&%20%E1%84%89%E1%85%AE%E1%84%92%E1%85%A1%E1%86%A8%20-%2012644fe8df284319a3ec05bb4aad6df5/Untitled%201.png)
>                 
>             - 답 : [17세]와 [맥주]
>         
>         - 카드 문제와 맥주 집 문제의 비교
>             - 맥주 집 문제가 휠씬 풀기 쉽다
>             - 사실, 두 문제는 완전히 같은 문제이다. 즉, 논리적 구성은 완전히 동일함
>             - 왜 맥주 집 문제가 풀기 쉬운가?
>             - 논리 구조를 정확히 이해하고 맥주 집 문제를 푸는 사람은 카드 문제를 똑같이 풀 수 있음
>             - 즉, 맥주 집 문제를 풀 때 논리를 사용한 것이 아니다!
>         
>         - 맥주 집 문제를 풀 때는 직관을 사용한 것
>         - 직관은 논리적인 느낌을 주는 것
>         - 직관의 장점은 (익숙한 상황에서) 빠르다는 것
>         - 직관의 단점은 정확하지 않다는 것 (가끔은 익숙한 상황에서도 틀림)
>         - 또 다른 단점은 강한 착각을 일으킨다는 것
>     
>     - 과자와 버스
>         - “너 과자 몇 개 먹었니?” vs “버스 타려고 하는데 천원 있니?”
>         - 두 질문은 같은 표현을 사용하지만, 하나는 정확한 개수를 요구하고, 다른 하나는 천원 이상이 있는지 물어보는 것
>     
>     - 토플과 복권
>         - “합격하려면 토플 500점 이상 혹은 토익 600점 이상이 필요” vs “복권에 당첨되면 자동차 혹은 천만원을 줍니다”
>         - 두 말은 같은 표현을 사용하지만 하나는 inclusive or, 다른 하나는 exclusive or
>     
>     - 일상 생활에서는
>         - Soft Logic이 빠르기 때문에 유용
>         - 논리적으로 부정확한 표현을 사용하지만, 어떤 의미인지 모든 사람이 이미 알고 있다는 가정이 존재
>     - 프로그래밍은 Hard Logic을 사용
>         - 프로그래밍 언어의 표현들이 모두 논리학에서 나온 것
>         - 사용되는 수 많은 알고리즘들을 이해하기 위해서는 Hard Logic이 필요
>     
>     - 오해의 근원
>         - Soft Logic으로 알고리즘을 이해하려고 하는 것!
>         - 알고리즘 설명을 보고 또 봐도 이해가 안되는 것은 증명을 안 봤기 때문
>         - 증명을 봐도 이해가 안되는 것은 직관으로 이해하려고 하기 때문
>         - 가끔 직관적으로 이해되는 알고리즘이 있지만 조금만 어려워지면 직관으로 완전한 이해를 얻는 것은 사실상 불가능
>         
> - 논리 연습
>     - 문제 1 : 다음을 명제 식 형태로 쓰고 참인지 거짓인지 판단하시오
>         1. 만약 0이 홀수라면, 미국에서 2080년 월드컵이 열린다. (답 : T)
>         2. 만약 1993827938274839이 Prime Number라면, 2는 짝수이다. (답 : T)
>     - 문제 2 : $p$와 $q$가 명제이고 $p$ → $q$가 거짓이라고 하자. 다음 명제식의 참 거짓은 어떻게 되는가?
>         1. ~$p$ → $q$ (답 : T)
>         2. $p\vee q$ (답 : T)
>         3. $q$ → $p$ (답 : T)
>     - 문제 3 : 다음 명제들의 역, 이, 대우를 쓰시오
>         1. 만약 0이 홀수라면, 미국에서 2080년 월드컵이 열린다. 
>         2. 만약 1993827938274839이 Prime Number라면, 2는 짝수이다.
>     - 문제 4 : 다음 명제식의 진리표를 만드시오
>         1.  $p$$\wedge$($q$→~$p$)
>             
>             $p$$\wedge$(~$q$ $\vee$~$p$)
>             
>             $p$$\wedge$~$q$ 
>             
>         2. ($p$$\wedge$~$q$)→$r$
>             
>             ~($p$$\wedge$~$q$)$\vee$$r$
>             
>             (~$p$$\vee$$q$)$\vee$$r$
>             
> - 증명
>     - 증명은 정확한 명제 식으로 표현할 수 있는 것이어야 함
>     - 보통은 정확한 명제 식까지 쓰지는 않으나 근본적으로는 명제 식으로 바꿀 수 있음
>     - 증명에 대한 수 많은 오해가 $p$  → $q$ 를 $p$  ↔ $q$ 와 혼동하는 것에서 일어남
>     
>     - 모든 당구 공은 색이 같다는 증명에서 잘못된 것은?
>         - 수학적 귀납법 : $P(1)$이 참이고, $P(n)$ → $P(n+1)$이 참이면 $P(n)$은 모든 자연 수 $n$에 대해서 참이다.
>         - 모든 자연 수 $n$에 대해 당구 공 $n$개가 들어있는 집합에서 그 집합에 포함된 당구 공은 모두 색이 같다는 것을 증명함
>         - $P(1)$ : 당구 공 1개가 들어있는 집합은 모두 색이 같음
>         - $P(n)$ → $P(n+1)$을 증명하기 위해 $P(n)$이 참이라고 가정
>         - 당구 공 $n+1$개가 들어있는 임의의 집합을 생각함
>         - 이 집합에서 하나를 빼면 당구 공 n개가 있는 집합이 되므로 지금 상황에서 모든 당구 공의 색이 같음
>         - 방금 뺀 원소를 다시 넣고, 다른 당구 공을 빼면 역시 당구 공 $n$개가 있는 집합이 되므로 지금 상황에서도 모든 당구 공의 색이 같음
>         - 위의 두 상황에서 처음 뺀 당구 공과 두 번째로 뺀 당구 공의 색이 같음을 알 수 있으므로 당구 공 $n+1$$P(1)$개가 들어있는 임의의 집합은 색이 같은 것 만을 포함함
>         1. 대부분의 사람들이 $P(n)$이 참이라고 가정할 수 없다고 반론함
>         2. 수학적 귀납법에서 필요한 것은 $P(n)$ → $P(n+1)$이 참임을 보이는 것 뿐이므로 $P(n)$이 정말로 참일 필요는 없음
>         3. 위 증명에서 실제로 잘못된 것은 다음 부분
>             - 위의 두 상황에서 처음 뺀 당구 공과 두 번째로 뺀 당구 공의 색이 같음을 알 수 있으므로…
>         4. 처음 뺀 당구 공과 두 번째로 뺀 당구 공의 색이 같다는 것은 공통 부분이 있다는 것인데, 실제로 $n=1$인 경우, 즉 $n+1 = 2$인 경우 공통 부분이 없음
>     
>     - Prime Number의 개수는 무한히 많다는 다음 증명은 옳은가?
>         - Prime Number의 개수가 유한한 $k$개라고 가정
>         - 모든 Prime Number를 다 곱하고 1을 더한 수를 $n$이라고 하자
>         - 이 수 $n$은 어떤 Prime으로 나누어도 나머지가 1이다.
>         - 그런데 $n$은 어떤 Prime보다도 크므로 합성 수이다.
>         - 합성 수이지만 어떤 Prime으로도 나누어지지 않으므로 모순 발생
>         1. 이 증명에 대한 반론으로 몇 개의 Prime이 더 존재하면 되는 것이 아니냐는 주장이 자주 있음
>         2. 위 증명은 “Prime Number가 $k$개 이면 모순이 발생”, 즉, “Prime Number가 $k$개” → “항상 거짓”, 이 명제가 항상 참임을 확인한 것
>         3. 즉, “Prime Number가 $k$개” 라는 명제가 항상 거짓일 수 밖에 없다!
> 
> - 수학적 귀납법과 증명의 수준
>     - 수학적 귀납법의 기본형 : $P(1)$이 참이고, $P(n)$ → $P(n+1)$이 참이면 $P(n)$은 모든 자연 수 $n$에 대해서 참이다.
>     - 수학적 귀납법의 강한 형태 : $P(1)$이 참이고, $P(1)$ $\wedge$ $P(1)$ $\wedge$ … $\wedge$$P(1)$ → $P(n+1)$이 참이면 $P(n)$은 모든 자연 수 $n$에 대해서 참이다.
>     - 다음 함수가 1부터 $x$까지의 합을 계산함을 증명해 보자
>         
>         ```c
>         int sum(int x){
>         	if(x <= 0)
>         		return 0;
>         	else
>         		return x + sum(x-1);
>         }
>         ```
>         
>     - High-Level 증명에서는 1부터 $x$까지의 합의 정의 중 하나인 $S(n) = S(n-1)+n$을 그대로 코딩한 것이므로 증명이 된 것이라고 말하는 경우가 많음
>     - 상세한 증명을 하려면 단순히 “답이 맞는 것이 당연하다”라고 말하는 것으로는 충분하지 않음
>         - 증명이 가능한 명제를 만들어야 함
>         - 이 경우 증명이 가능한 명제는 다음과 같음 : “sum(x) 가 리턴 하는 값은 $1+2+...+x$의 값과 항상 같다”
>         - 이제 수학적 귀납법을 적용할 수 있음
>         - $P(1)$이 참이다 : “sum(1) 이 리턴하는 값은 1이다” 를 증명하면 됨. 실제 코드에 1을 대입하면 1을 리턴함을 알 수 있음
>         - $P(x)$ → $P(x+1)$ 이 참이다 : “sum(x-1) 이 $1+2+...+(x-1)$을 리턴하면 sum(x)는 $1+2+...+x$를 리턴한다” 를 증명하면 됨. 코드를 보면 sum(x)는 x + sum(x-1)의 값을 리턴함. sum(x-1)의 리턴 값은 $1+2+...+(x-1)$과 같다고 가정했으므로 sum(x)는 $1+2+...+x$를 리턴함을 확인할 수 있음
>         - sum(x-1)을 블랙박스로 보는 것이 이해에 도움을 줄 때가 있음
>     
>     - 소팅의 사례
>         - High-level 증명에서는 소팅이 된다는 것을 직관적인 수준에서 설명하는 경우가 많음
>         - 상세한 증명을 위해서는 증명이 가능한 명제가 필요
>         - 배열 $A[1],A[2],...A[n]$을 소팅하는 알고리즘의 정확성을 증명하려고 한다면, 증명이 가능한 명제는 다음과 같을 것임 : “$A[1]<A[2]<...<A[n]$”
>         - 버블 소트가 정확함을 어떻게 증명할 지 생각해 봅시다.
> 
> - 증명 연습
>     - Trivial Proof : $\forall x$, $P(x)$ → $Q(x)$를 증명 하려는 데, $Q(x)$가 항상 참인 경우
>     - 문제 1 : 다음 명제를 증명하시오
>         1. 실수 $x$에 대해, 만약 $x<-1$이면 $x^2+\frac{1}{4} >0$이다.
>         2. $n$이 홀수이면 $4n^3 + 6n^2+12$는 짝수이다.
>     
>     - Vacuous Proof : $\forall x$, $P(x)$ → $Q(x)$를 증명 하려는 데, $P(x)$가 항상 거짓인 경우
>     - 문제 2 : 다음 명제를 증명하시오
>         1. 실수 $x$에 대해, 만약 $2x^2-4x+4<0$이면 $x>8$이다.
>         2. $4n^3+6n^2+11$는 짝수이면 $n$이 홀수이다.

---

### [참고]

> **[참고]**
> 
> - 명제
>     - 참이나 거짓을 알 수 있는 식이나 문장.
>     - $p, q, r...$ 로 표현
>         
>         예) 서울은 대한민국의 수도다.
>         
>         1+1 = 3
>         
> - 진릿값
>     - 참이나 거짓을 표현.
>     - T, F 또는 1, 0
>         
>         ![Untitled](Computational%20Thinking%20-%20%E1%84%80%E1%85%B5%E1%84%8E%E1%85%A9%20%E1%84%82%E1%85%A9%E1%86%AB%E1%84%85%E1%85%B5%20&%20%E1%84%89%E1%85%AE%E1%84%92%E1%85%A1%E1%86%A8%20-%2012644fe8df284319a3ec05bb4aad6df5/Untitled%202.png)
>         
> - 연산(결합)
>     - 부정 : NOT
>         - $p$가 명제일 때, 명제의 진릿값이 반대
>         - ~$p$ 또는 ㄱ$p$로 표기 (not $p$ 또는 $p$의 부정으로 읽음)
>             
>             ![Untitled](Computational%20Thinking%20-%20%E1%84%80%E1%85%B5%E1%84%8E%E1%85%A9%20%E1%84%82%E1%85%A9%E1%86%AB%E1%84%85%E1%85%B5%20&%20%E1%84%89%E1%85%AE%E1%84%92%E1%85%A1%E1%86%A8%20-%2012644fe8df284319a3ec05bb4aad6df5/Untitled%203.png)
>             
>     - 논리곱 : AND
>         - $p$, $q$가 명제일 때, $p$, $q$ 모두 참일 때만 참이 되는 명제.
>         - $p\wedge q$ ($p$ and $q$, $p$ 그리고 $q$)
>             
>             ![Untitled](Computational%20Thinking%20-%20%E1%84%80%E1%85%B5%E1%84%8E%E1%85%A9%20%E1%84%82%E1%85%A9%E1%86%AB%E1%84%85%E1%85%B5%20&%20%E1%84%89%E1%85%AE%E1%84%92%E1%85%A1%E1%86%A8%20-%2012644fe8df284319a3ec05bb4aad6df5/Untitled%204.png)
>             
>     - 논리합 : OR
>         - $p$, $q$가 명제일 때, $p$, $q$ 모두 거짓일 때만 거짓이 되는 명제.
>         - $p\vee q$ ($p$ or $q$, $p$ 또는 $q$)
>             
>             ![Untitled](Computational%20Thinking%20-%20%E1%84%80%E1%85%B5%E1%84%8E%E1%85%A9%20%E1%84%82%E1%85%A9%E1%86%AB%E1%84%85%E1%85%B5%20&%20%E1%84%89%E1%85%AE%E1%84%92%E1%85%A1%E1%86%A8%20-%2012644fe8df284319a3ec05bb4aad6df5/Untitled%205.png)
>             
>     - 배타적 논리합 : XOR
>         - $p$, $q$가 명제일 때, $p$, $q$ 중 하나만 참일 때만 참이 되는 명제.
>         - $p\oplus q$ ($p$ xor $q$)
>             
>             ![Untitled](Computational%20Thinking%20-%20%E1%84%80%E1%85%B5%E1%84%8E%E1%85%A9%20%E1%84%82%E1%85%A9%E1%86%AB%E1%84%85%E1%85%B5%20&%20%E1%84%89%E1%85%AE%E1%84%92%E1%85%A1%E1%86%A8%20-%2012644fe8df284319a3ec05bb4aad6df5/Untitled%206.png)
>             
> 
> - [합성]
>     - 연산자 우선 순위
>         - ~ > $\vee$, $\wedge$ > →,  ↔
>     - 항진 명제 : 진릿값이 항상 참
>     - 모순 명제 : 진릿값이 항상 거짓
>     - 사건 면제 : 항진 명제도 모순 명제도 아닌 명제
>     - 조건 명제 :
>         - $p$, $q$ 가 명제일 때, 명제 $p$가 조건(또는 원인), $q$가 결론(또는 결과)로 제시되는 명제.
>         - $p$  → $q$ ($p$ 이면 $q$이다.)
>             
>             ![Untitled](Computational%20Thinking%20-%20%E1%84%80%E1%85%B5%E1%84%8E%E1%85%A9%20%E1%84%82%E1%85%A9%E1%86%AB%E1%84%85%E1%85%B5%20&%20%E1%84%89%E1%85%AE%E1%84%92%E1%85%A1%E1%86%A8%20-%2012644fe8df284319a3ec05bb4aad6df5/Untitled%207.png)
>             
>     - 쌍방 조건 명제 :
>         - $p$, $q$ 가 명제일 때, 명제 $p$와 $q$가 모두 조건이면서 결론인 명제.
>         - $p$  ↔ $q$ ($p$ 면 $q$고, $q$ 면 $p$다.)
>             
>             ![Untitled](Computational%20Thinking%20-%20%E1%84%80%E1%85%B5%E1%84%8E%E1%85%A9%20%E1%84%82%E1%85%A9%E1%86%AB%E1%84%85%E1%85%B5%20&%20%E1%84%89%E1%85%AE%E1%84%92%E1%85%A1%E1%86%A8%20-%2012644fe8df284319a3ec05bb4aad6df5/Untitled%208.png)
>             
> 
> - 조건 명제의 역, 이, 대우
>     - 역 : $q$ → $p$
>     - 이 : ~$p$ → ~$q$
>     - 대우 : ~$q$ → ~$p$

---

## 2. 논리와 증명

> **논리와 증명**
> 
> - 문제 1 : 다음 명제들이 항진 명제라는 것을 진리표를 이용해서 보이시오
>     1. ~( ~$p$ $\wedge$ $q$) $\vee$ $q$
>     2. ( ~ $p$ $\vee$ $q$ ) $\vee$ ( $$ $p$ $\wedge$ ~ $q$ )
> 
> - 문제 2 : 다음 명제들이 모순 명제라는 것을 진리표를 이용해서 보이시오
>     1. ( ~$p$ $\vee$$q$)$\wedge$($p$ $\wedge$~$q$)
>     2. ($p$ $\wedge$ $q$) $\wedge$ ($p$ $\wedge$ ~ $q$)
> 
> - 문제 3 : 다음 명제의 쌍에 대해서 두 명제가 동등한지를 진리표를 이용해 확인하시오.
>     1. $p$ $\wedge$ ( $p$ $\vee$ $q$) 와 $p$
>     2. ~ $p$ $\vee$ ~ $q$와 ~ ($p$ $\vee$ $q$)
> 
> - 문제 4 : 명제 식의 변형을 통하여 다음 명제를 간소화하시오.
>     1. ($p$ $\wedge$ ~ $q$) $\vee$ ($p$ $\wedge$  $q$)
>     2. ($p$ $\vee$ ~ $q$) $\wedge$ (~ $p$ $\vee$ ~ $q$)
> 
> - 문제 5 : 다음 명제들이 참인지 확인하시오. 단 $R$은 실수의 집합을 의미하고, $Z$는 정수의 집합을 의미한다.
>     1. $\forall x \in R$, $x^2 \geq x$
>     2. $\forall x \in Z$, $x^2 \geq x$
>     3. $\exist x \in R$, $x^2 < x$
>     4. $\exist x \in Z$, $x^2 < x$
> 
> - 문제 6 : (직접 증명) $n$이 짝수이면 $3n+5$는 홀수임을 증명하라.
> 
> - 문제 7 : $n$이 홀수이면 $n^2+n$은 짝수임을 증명하라
> 
> - 문제 8 : $m$이 짝수이고 $n$이 홀수이면 $2m+3n$은 홀수임을 증명하라
> 
> - 문제 9 : 자연 수 $n$에 대해, $n^2 + 5$가 홀수이면 $n$은 짝수임을 증명하라
> 
> - 문제 10 : $n^2$이 짝수이면 $n$이 짝수임을 증명하라.
> 
> - 문제 11 : 자연수 $n$에 대해 $n^2+5n+3$은 항상 홀수임을 증명하라.
> 
> - 문제 12 : $n^2$이 3의 배수이면 $n$은 3의 배수임을 증명하라.
> 

---

## 3. 수와 표현

> **수와 표현**
> 
> - 약간의 설명
>     - 컴퓨터는 0/1 을 표현할 수 있는 비트 들을 모아 수를 표현
>     - $k$개의 비트를 사용하면 0부터 $2^{k}-1$까지 표현 가능
>     - 사실, 꼭 저 범위인 것은 아님. 약속하는 방식에 따라 다르지만, 어떤 경우든 최대 $2^k$ 가지의 값을 표현하는 것이 가능
>     - 10진수로 $k$자리를 쓰면 0부터 $10^k-1$까지 표현이 가능한 것과 완전히 동일한 과정
>     
>     - 어떤 값 $n$을 표현하기 위해서는 몇 개의 비트가 필요할 까?
>     - $2^k-1 \geq n$이 성립해야 함 → 즉, $2^k \geq n+1$
>     - 같은 의미로, $k \geq \log(n+1)$ → 약 $\log n$ 비트가 필요
>     - $x = \log n$과 $2^x = n$은 같은 말
>     
>     - 위의 식을 잘 보면 , $\log n$이란
>         1. 2의 몇 승이 $n$이 되는가 의 답
>         2. $n$을 표현하는 데 몇 비트가 필요한가 의 답
>         3. 1로 시작해서 계속 두 배를 할 때 몇 번 하면 $n$이 되는가 의 답
>         4. $n$을 2로 계속 나눌 때 몇 번 나누면 거의 1이 되는가에 대한 답
>         
>     - $x = \log n$일 때 $x$와 $n$을 비교하면 $x$가 더 작고, $n$이 커질수록 엄청나게 달라진다.
>     - 100자리로 표현할 수 있는 10진수 값은 읽을 수도 없을 정도로 큰 값이다.
>     - 컴퓨터 분야에서 로그의 밑은 항상 2
>     
>     - 32비트 컴퓨터의 주소 공간은 $2^{32}$ = 약 40억개 주소
>     - $n +(\frac{n}{2}+\frac{n}{2})+(\frac{n}{4}+\frac{n}{4}+\frac{n}{4}+\frac{n}{4})+...+(1+1+...) = n\log n$ (WHY?)
>     - $n + \frac{n}{2} + \frac{n}{4}+...+1 \simeq 2n$
>     - 위 두 식의 항의 개수는 $\log n$개 (WHY?)
> 
> - 문제들
>     - 문제 1 : 2진수 표현에서 $\log n$비트로 표현할 수 있는 숫자 범위는?
>         
>         
>     - 문제 2 : 스무 고개가 이상적으로 진행된다고 할 때, 맞출 수 있는 답의 종류는 몇 가지인가?
>     
>     - 문제 3 : $n$이 충분히 큰 값일 때 다음 중 어느 값이 더 큰가? 각 쌍에 대해 비교하고 그 이유를 작성하시오.
>         1. $2^{n} \space\space(\space \space \space)\space\space n^2$
>         2. $2^{\frac{n}{2}} \space\space(\space \space \space)\space\space \sqrt{3^{n}}$
>         3. $2^{n\log n} \space\space(\space \space \space)\space\space n!$
>         4. $\log {2^{2n}} \space\space(\space \space \space)\space\space n\sqrt{n}$
>         
>     - 문제 4 : $x = \log_{a}{yz}$일 때 $x$를 2를 밑으로 하는 로그 들로 표현하시오. 단, 로그 함수 인자는 모두 문자 하나 여야 한다.
>     
>     - 문제 5 : 다음 함수들의 역 함수를 구하시오
>         1. $f(x) = \log(x-3) - 5$
>         2. $f(x) = 3\log(x+3) +1$
>         3. $f(x) = 2\times 3^{x} -1$

---

## 4. 집합과 조합론

> **집합과 조합론**
> 
> - 집합과 조합론에 대한 약간의 설명
>     - 두 집합 A와 B에 대해 A가 B의 부분 집합임을 증명한다는 것은 A의 임의의 원소가 B에 포함됨을 보이는 것과 같다.
>     - 예를 들어 모든 4의 배수는 2의 배수라는 것을 증명하려면, $4k = 2(2k)$ 임을 보이면 되는 것이다.
>     - 두 집합 A와 B가 같다는 것을 증명하기 위해서는 A가 B의 부분 집합이고 B가 A의 부분 집합임을 증명하면 된다.
>