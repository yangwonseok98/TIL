# 문자열(String)

---

## INDEX

> **INDEX**
> 
> - 문자열
> - 패턴 매칭
> - 문자열 암호화
> - 문자열 압축

---

## 문자의 표현

### 문자의 표현

> **문자의 표현**
> 
> - 컴퓨터에서의 문자표현
>     - 글자 A를 메모리에 저장하는 방법에 대해서 생각해보자
>     - 물론 칼로 A라는 글자를 새기는 방식은 아닐 것이다. 메모리는 숫자만을 저장할 수 있기 때문에 A라는 글자의 모양 그대로 비트맵으로 저장하는 방법을 사용하지 않는 한(이 방법은 메모리 낭비가 심하다) 각 문자에 대해서는 대응되는 숫자를 정해 놓고 이것을 메모리에 저장하는 방법이 사용될 것이다.
>     - 영어가 대소문자 합쳐서 52 이므로 6(64가지)비트면 모두 표현할 수 있다. 이를 코드체계라고 한다.
>         - 000000 → ‘a’, 000001 → ‘b’
> 
> - 그런데 네트워크가 발전되기 전 미국의 각 지역 별로 코드체계를 정해 놓고 사용했지만
> 
> - 네트워크(인터넷 : 인터넷은 미국에서 발전했다)가 발전하면서 서로간에 정보를 주고 받을 때 정보를 달리 해석한다는 문제가 생겼다.
> 
> - 그래서 혼동을 피하기 위해 표준안을 만들기로 했다.
> 
> - 바로 이러한 목적으로 1967년, 미국에서 ASCII(American Standard Code for Information Interchange)라는 문자 인코딩 표준이 제정되었다.
> 
> - ASCII는 7bit 인코딩으로 128문자를 표현하며 33개의 출력 불가능한 제어 문자들과 공백을 비롯한 95개의 출력 가능한 문자들로 이루어져 있다.
> 
> - 출력 가능 아스키 문자(32 ~ 126)
>     
>     ![image](https://github.com/yangwonseok98/TIL/assets/132911926/50dc34b3-8a62-45b3-a744-79803803e7a1)

>     
> 
> - 확장 아스키는 표준 문자 이외의 악센트 문자, 도형 문자, 특수 문자, 특수 기호 등 부가적인 문자를 128개 추가할 수 있게 하는 부호이다.
>     - 표준 아스키는 7bit를 사용하여 문자를 표현하는 데 비해 확장 아스키는 1B 내의 8bit를 모두 사용함으로써 추가적인 문자를 표현할 수 있다.
>     - 컴퓨터 생산자와 소프트웨어 개발자가 여러 가지 다양한 문자에 할당할 수 있도록 하고 있다. 이렇게 할당된 확장 부호는 표준 아스키와 같은 서로 다른 프로그램이나 컴퓨터 사이에 교환되지 못한다.
>     - 그러므로 표준 아스키는 마이크로컴퓨터 하드웨어 및 소프트웨어 사이에서 세계적으로 통용되는 데 비해, 확장 아스키는 프로그램이나 컴퓨터 또는 프린터가 그것을 해독할 수 있도록 설계되어 있어야만 올바로 해독될 수 있다.
> 
> - 확장 아스키 예
>     
>     ![image](https://github.com/yangwonseok98/TIL/assets/132911926/77192592-e5a2-47a4-95c5-0c293589aff9)

>     
> 
> - 오늘날 대부분의 컴퓨터는 문자를 읽고 쓰는데 ASCII형식을 사용한다.
> 
> - 그런데 컴퓨터가 발전하면서 미국 뿐 아니라 각 나라에서도 컴퓨터가 발전했으며 각 국가들은 자국의 문자를 표현하기 위하여 코드체계를 만들어서 사용하게 되었다.
>     - 우리나라도 아주 오래된 이야기지만 한글 코드체계를 만들어 사용했고 조합형, 완성형 두 종류를 가지고 있었다.
> 
> - 인터넷이 전 세계로 발전하염서 ASCII를 만들었을 때의 문제와 같은 문제가 국가간에 정보를 주고 받을 때 발생했다.
> 
> - 자국의 코드체계를 타 국가가 가지고 있지 않으면 정보를 잘못 해석할 수 밖에 없었다.
> 
> - 그래서 다국어 처리를 위해 표준을 마련했다 이를 유니코드라고 한다.
> 
> - 유니코드의 일부
>     
>     ![image](https://github.com/yangwonseok98/TIL/assets/132911926/0d7f5851-54f6-4a20-b540-231ef657547e)

>     
> 
> - 유니코드도 다시 Character Set으로 분류된다.
>     - UCS-2(Universal Character Set 2)
>     - UCS-4(Universal Character Set 4)
>     - 유니코드를 저장하는 변수의 크기를 정의
>     - 그러나, 바이트 순서에 대해서 표준화하지 못했음.
>     - 다시 말해 파일을 인식 시 이 파일이 UCS-2, UCS-4인지 인식하고 각 경우를 구분해서 모두 다르게 구현해야 하는 문제 발생
>     - 그래서 유니 코드의 적당한 외부 인코딩이 필요하게 되었다.
> 
> - big-endian, little-endlian:
>     - 인텔 : 리틀 엔디안
>     - 과거 AMD : 빅 엔디안
>     - 8bit를 어떤 순서로 메모리에 올리느냐
> 
> - 유니코드 인코딩(UTF : Unicode Transformation Format)
>     - UTF-8 (in web)
>         - MIN : 8bit, MAX : 32bit(1 Byte * 4)
>     - UTF-16 (in windows, java)
>         - MIN : 16bit, MAX : 32bit(1 Byte * 4)
>     - UTF-32 (in unix)
>         - MIN : 32bit, MAX : 32bit(1 Byte * 4)
>     
> - Python 인코딩
>     - 2x 버전 - ASCII → #-*- coding :  utf-8 -*- (첫 줄에 명시)
>     - 3x 버전 - 유니코드 UTF-8 → 생략 가능
>     - 다른 인코딩 방식으로 처리 시 첫 줄에 작성하는 위 항목에 원하는 인코딩 방식을 지정해주면 됨

---

## 문자열

### 문자열

> **문자열의 분류**
> 
> - 문자열(string)
>     - fixed length
>     - variable length
>         - length controlled : java 언어에서의 문자열
>         - delimited : C 언어에서의 문자열

> **java에서 String 클래스에 대한 메모리 배치 예**
> 
> - 그림에서 보이듯, java.lang.String 클래스에는 기본적인 객체 메타 데이터 외에도 네 가지 필드들이 포함되어 있는데, hash값(hash), 문자열의 길이(count), 문자열 데이터의 시작점(offset), 그리고 실제 문자열 배열에 대한 참조(value)이다.
>     
>     ![image](https://github.com/yangwonseok98/TIL/assets/132911926/cdc5456f-60c9-4d14-9a54-e6509b85e8a2)

>     

> **C언어에서 문자열 처리**
> 
> - 문자열을 문자들의 배열 형태로 구현된 응용 자료형
> - 문자배열에 문자열을 저장할 때는 항상 마지막 끝을 표시하는 널문자(’\0’)를 넣어줘야 한다.
>     
>     ```c
>     char ary[] = {'a', 'b', 'c', '\0'};
>     char ary[] = "abc";
>     ```
>     
> - 문자열 처리에 필요한 연산을 함수 형태로 제공한다.
>     
>     ```c
>     #include<string.h>
>     strlen(), strcpy(), strcmp()...
>     ```
>     

> **[참고]**
> 
> - 다음 두 코드의 차이 이해하기
>     
>     ```python
>     s1 = list(input())
>     s2 = input()
>     ```
>     
> - strlen() 함수 만들어 보기
>     
>     ```python
>     def strlen(a):
>         idx = 0
>         while a[idx] != '\0':
>             idx += 1
>         return idx
>     
>     a = ['a', 'b', 'c', '\0']
>     print(strlen(a))
>     ```
>     

> **Java(객체지향 언어)에서의 문자열 처리**
> 
> - 문자열 데이터를 저장, 처리해주는 클래스를 제공한다.
> - String클래스를 사용한다.
>     
>     ```java
>     String str = "abc";
>     String str = new String("abc")
>     ```
>     
> - 문자열 처리에 필요한 연산을 연산자, 메소드 형태로 제공한다.
>     - +, length(), replace(), split(), substring()
>     - 보다 풍부한 연산을 제공한다.

> **Python에서의 문자열 처리**
> 
> - char 타입 없음
> - 텍스트 데이터의 취급방법이 통일되어 있음
> - 문자열 기호
>     - ‘(홑 따옴표), “(쌍 따옴표), ‘’’(홑 따옴표 3개), “””(쌍 따옴표 3개)
>     - + 연결(Concatenation)
>         - 문자열 + 문자열 : 이어 붙여주는 역할
>     - * 반복
>         - 문자열 * 수 : 수 만큼 문자열이 반복
> - 문자열은 시퀀스 자료형으로 분류되고, 시퀀스 자료형에서 사용할 수 있는 인덱싱, 슬라이싱 연산들을 사용할 수 있음
> - 문자열 클래스에서 제공되는 메소드
>     
>     ```python
>     replace(), split(), isalpha(), find()
>     ```
>     
> - 문자열은 튜플과 같이 요소값을 변경 할 수 없음(immutable)

> **C와 Java의 String 처리의 기본적인 차이점**
> 
> - C는 아스키 코드로 저장한다.
> - java는 유니코드(UTF16, 2byte)로 저장한다.
> - 파이썬은 유니코드(UTF8)로 저장
>     
>     ```c
>     char *name = "홍길동";
>     int count = strlen(name);
>     printf("%d", count); //6
>     ```
>     
>     ```java
>     String name = "홍길동";
>     System.out.println(name.length());//3
>     ```
>     
>     ```python
>     name = "홍길동"
>     print(len(name)) #3
>     ```
>     

---

### 문자열 뒤집기

> **문자열 뒤집기**
> 
> - 자기 문자열에서 뒤집는 방법이 있고 새로운 빈 문자열을 만들어 소스의 뒤에서부터 읽어서 타겟에 쓰는 방법이 있겠다.
> - 자기 문자열을 이용할 경우는 swap을 위한 임시 변수가 필요하며 반복 수행을 문자열 길이의 반만을 수행해야 한다.
>     
>     ```python
>     s = 'algorithm'
>     s = list(s)
>     for i in range(0, len(s)//2):
>         s[i], s[len(s)-1-i] = s[len(s)-1-i], s[i]
>     s = ''.join(s)
>     print(s) # mhtirogla
>     ```
>     

> **<연습문제1> 문자열 뒤집기**
> 
> - Python에서 문자열 뒤집기
>     
>     Ex) s = ‘Reverse this string’ # ‘sgnirts siht esreveR’
>     
>     ```python
>     s = 'Reverse this string'
>     s = s[::-1]
>     print(s)
>     
>     s = 'Reverse this string'
>     s = list(s)
>     s.reverse()
>     s = ''.join(s)
>     print(s)
>     ```
>     
> 
> - for 문을 이용해 구현해봅시다.
>     
>     ```python
>     s = 'Reverse this string'
>     s = list(s)
>     for i in range(0, len(s)//2):
>         s[i], s[len(s)-1-i] = s[len(s)-1-i], s[i]
>     s = ''.join(s)
>     print(s)
>     ```
>     

---

### 문자열 비교

> **문자열 비교**
> 
> - c strcmp() 함수를 제공한다.
> - Java에서는 equals() 메소드를 제공한다.
>     - 문자열 비교에서 == 연산은 메모리 참조가 같은지를 묻는 것
> - 파이썬에서는 == 연산자와 is 연산자를 제공한다.
>     - == 연산자는 내부적으로 특수 메서드 `__eq__()` 를 호출
>     
>     [참고] s1과 나머지 문자열을 ==, is 로 비교한 결과를 확인해보세요.
>     
>     ```python
>     s1 = 'abc'
>     s2 = 'abc'
>     s3 = 'def'
>     s4 = s1
>     s5 = s1[:2] + 'c'
>     
>     print(s1 == s2)     # True
>     print(s1 == s3)     # False
>     print(s1 == s4)     # True
>     print(s1 == s5)     # True
>     
>     print(s1 is s2)     # True
>     print(s1 is s3)     # False
>     print(s1 is s4)     # True
>     print(s1 is s5)     # False
>     ```
>     

> **다음 C 코드를 참고해 문자열 비교함수를 만들어 보자**
> 
> - 문자열이 같으면 0리턴
> - str1이 str2보다 사전 순서상 앞서면 음수 혹은 리턴 -1
> - str1이 str2보다 사전 순서상 나중이면 양수 혹은 1 리턴
>     
>     ```c
>     int my_strcmp(const char *str1, const char *str){
>     	int i=0;
>     	while(str1[i] != '\0'){
>     		if(str1[i] != str2[i])
>     			break;
>     		i++;
>     	}
>     	return (str1[i] - str2[i]);
>     }
>     ```
>     
>     ```python
>     def my_strcmp(str1, str2):
>         n1 = len(str1)
>         n2 = len(str2)
>         idx = 0
>         while idx < min(n1, n2):
>             if str1[idx] < str2[idx]:
>                 return -1
>             elif str1[idx] > str2[idx]:
>                 return 1
>             else:
>                 idx += 1
>         if n1 < n2:
>             return -1
>         else:
>             return 1
>     ```
>     

---

### 문자열 숫자를 정수로 변환하기

> **문자열 숫자를 정수로 변환하기**
> 
> - C 언어에서는 `atoi()`함수를 제공한다. 역함수로는 `itoa()` 가 있다.
> - java에서는 숫자 클래스의 parse 메소드를 제공한다.
>     - 예 : `Inetger.parselnt(String)`
>     - 역함수로는 `toString()` 메소드를 제공한다.
> - 파이썬에서는 숫자와 문자변환 함수를 제공한다.
>     - 예 : `int(”123”)` , `float(”3.14”)` , `str(123)` , `repr(123)`
> - int() 와 같은 atoi() 함수 만들기
>     
>     ```python
>     def atoi(s):
>         i = 0
>         for x in s:
>             i = i*10 + ord(x) - ord('0')
>         return i
>     
>     s = '123'
>     a = atoi(s)
>     print(a+1)
>     ```
>     

> **<연습문제2>**
> 
> - str() 함수를 사용하지 않고, itoa()를 구현해 봅시다.
>     - 양의 정수를 입력받아 문자열로 변환하는 함수
>     - 입력 값 : 변환할 정수 값, 변환된 문자열을 저장할 문자배열
>     - 반환 값 : 없음
>         
>         [참고] ord(), chr()
>         
>     - 음수를 변환할 때는 어떤 고려 사항이 필요한가요?
>         
>         ```python
>         def itoa(i):
>             res = ''
>             if i < 0:
>                 s = '-'
>                 tmp = -i
>             else:
>                 s = ''
>                 tmp = i
>         
>             while tmp != 0:
>                 res = chr(tmp % 10 + ord('0')) + res
>                 tmp //= 10
>         
>             return s + res
>         
>         print(itoa(-1579) + '0') # -15790
>         print(itoa(1234) + '0') # 12340
>         ```
>         

---

## 패턴 매칭

### 패턴 매칭에 사용되는 알고리즘들

> **패턴 매칭에 사용되는 알고리즘들**
> 
> - 고지식한 패턴 검색 알고리즘
> - 카프 - 라빈 알고리즘
> - KMP 알고리즘
> - 보이어-무어 알고리즘

> **고지식한 알고리즘(Brute-Force)**
> 
> - 본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴 내의 문자들을 일일이 비교하는 방식으로 동작
>     
>     ```python
>     def BruteForce(p, t, M, N):
>         i = 0
>         j = 0
>         while i < N and j < M:
>             if t[i] != p[j]:
>                 i += 1 - j
>                 j = 0
>             else:
>                 i += 1
>                 j += 1
>         if j == M:
>             return i - M
>         else:
>             return -1
>     
>     p = "is"
>     t = "This is a book~!"
>     M = len(p)
>     N = len(t)
>     print(BruteForce(p, t, M, N))
>     ```
>     
> - 고지식한 페턴 검색 알고리즘의 시간 복잡도
>     - 최악의 경우 시간 복잡도는 텍스트의 모든 위치에서 패턴을 비교해야 하므로 O(MN)이 됨
>     - 길이가 10000인 문자열에서 길이 80인 패턴을 찾는다고 할 때, 최악의 경우 약 10,000*80 = 800,000 번의 비교가 일어난다.
>     - 비교횟수를 줄일 수 있는 방법은 없는가?

> **KMP 알고리즘**
> 
> - 불일치가 발생한 텍스트 스트링의 앞 부분에 어떤 문자가 있는지를 미리 알고 있으므로, 불일치가 발생한 앞 부분에 대하여 다시 비교하지 않고 매칭을 수행
> - 패턴을 전처리하여 배열  next[M]을 구해서 잘못된 시작을 최소화함
>     - next[M] : 불일치가 발생했을 경우 이동할 다음 위치
> - 시간 복잡도 : O(M+N)
> - 아이디어 설명
>     - 텍스트에서 abcdabc까지는 매치되고, e에서 실패한 상황 패턴의 맨 앞의 abc와 실패 직전의 abc는 동일함을 이용할 수 있다.
>     - 실패한 텍스트 문자와 P[4]를 비교한다.
>         
>         ![image](https://github.com/yangwonseok98/TIL/assets/132911926/f1b37866-d366-42e7-bb89-477052a2579a)
>
>         
>     - 매칭이 실패했을 때 돌아갈 곳을 계산한다.
>         
>         ![image](https://github.com/yangwonseok98/TIL/assets/132911926/20a93d80-a25c-409b-84b4-67863c1cb3ab)
>         

> **보이어-무어 알고리즘**
> 
> - 오른쪽에서 왼쪽으로 비교
> - 대부분의 상용 소프트웨어에서 채택하고 있는 알고리즘
> - 보이어-무어 알고리즘은 패턴에 오른쪽 끝에 있는 문자가 불일치 하고 이 문자가 패턴 내에 존재하지 않는 경우, 이동거리는 무려 패턴이 길이 만큼이 된다.
>     
>     ![image](https://github.com/yangwonseok98/TIL/assets/132911926/0dffcaf3-e7f4-4acf-9959-027ca4b381d1)
>     
> - 오른쪽 끝에 있는 문자가 불일치 하고 이 문자가 패턴 내에 존재할 경우
>     
>     ![image](https://github.com/yangwonseok98/TIL/assets/132911926/1485ab7b-c380-46f5-9280-7f74f7b78647)
>     
> - 보이어-무어 알고리즘을 이용한 예
>     
>     ![image](https://github.com/yangwonseok98/TIL/assets/132911926/a74e7746-d66b-4366-84da-55f2c0c56178)
>     
>     - rithm 문자열의 skip 배열
>         
>         
>         | m | h | t | i | r | 다른 모든 문자 |
>         | --- | --- | --- | --- | --- | --- |
>         | 0 | 1 | 2 | 3 | 4 | 5 |
> - 문자열 매칭 알고리즘 비교
>     - 찾고자 하는 문자열 패턴의 길이 m, 총 문자열 길이 n
>     - 고지식한 패턴 검색 알고리즘 : 수행시간 O(mn)
>     - 카프-라빈 알고리즘 : 수행시간 O(n)
>     - KMP 알고리즘 : 수행시간 O(n)
> - 보이어-무어 알고리즘
>     - 앞의 두 매칭 알고리즘들의 공통점 텍스트 문자열의 문자를 적어도 한 번씩 훑는다는 점이다, 따라서 최선의 경우에도 O(n)
>     - 보이어-무어 알고리즘은 텍스트 문자를 다 보지 않아도 된다
>     - 발상의 전환 : 패턴의 오른쪽부터 비교한다
>     - 최악의 경우 수행시간 : O(mn)
>     - 입력에 따라 다르지만 일반적으로 O(n)보다 시간이 덜 든다.

> **<연습문제 3>**
> 
> - 고지식한 방법을 이용하여 패턴을 찾아 봅시다.
> - 임의의 본문 문자열과 찾을 패턴 문자열을 만듭니다.
> - 결과 값으로 찾은 위치 값을 결과로 출력합니다.
>     
>     ```python
>     def bruteforce(ts, lts, fs, lfs):
>         i = 0
>         j = 0
>         while i < lts and j < lfs:
>             if ts[i] != fs[j]:
>                 i += -j + 1
>                 j = 0
>             else:
>                 j += 1
>                 i += 1
>         if j == lfs:
>             return i - lfs
>         else:
>             return -1
>     
>     total_s = "ABCABABCDE"
>     find_s = "ABCD"
>     print(bruteforce(total_s, len(total_s), find_s, len(find_s)))
>     ```
>     

---

## 문자열 암호화

### 시저 암호(Caesar cipher)

> **시저 암호(Caesar cipher)**
> 
> - 줄리어스 시저가 사용했다고 하는 암호이다.
> - 시저는 기원전 100년경에 로마에서 활약했던 장군이었다.
> - 시저 암호에서는 평문에서 사용되고 있는 알파벳을 일정한 문자수만큼 [평행이동] 시킴으로써 암호화를 행한다.
> 
> - 1만큼 평행했다는 카이사르 암호화의 예
>     
>     
>     | 평문 | S | A | V | E |  | P | R | I | V | A | T | E |  | R | Y | A | N |
>     | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
>     | 암호문 | T | B | W | F | A | Q | S | J | W | B | U | F | A | S | Z | B | O |
>     - 1 만큼 평행했을 때 1을 키값이라 한다.
>     - 수신자 이외의 사람(키가 1이라는 사실을 모르는 사람)이 암호문을 보고 다른 정보 없이도 평문을 맞출 수는 없을까?
>     - 다시말해, 시저 암호를 해독할 수 없을까?
> 
> - 시저 암호문에 대한 전사공격
>     - 모든 키 값(1~25)에 대한 평문을 다 구해본다.

---

### 문자 변환표를 이용한 암호화(단일 치환 암호)

> **문자 변환표를 이용한 암호화(단일 치환 암호)**
> 
> - 단순한 카이사르 암호화보다 훨씬 강력한 암호화 기법
> - 문자 변환표의 예
>     
>     
>     |  | A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z |
>     | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
>     | Q | H | C | B | E | J | K | A | R | W | S | T | U | V | D |  | I | O | P | X | Z | F | G | L | M | N | Y |
> - 위 변환표를 사용한 암호화의 예
>     
>     
>     | 평문 | S | A | V | E |  | P | R | I | V | A | T | E |  | R | Y | A | N |
>     | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
>     | 암호문 | X | H | G | J | Q | I | P | W | G | H | Z | J | Q | P | N | H | D |
> 
> - 단일 치환 암호의 복호화
>     - 복호화 하기 위해서는 모든 키 조합(key space)가 필요하다.
> - 단일 치환 암호의 키의 총 수는
>     - $26\times25\times24\times...\times1 = 26! = 403291461126605635584000000$
> - 1초에 10억 개의 키를 적용하는 속도로 조사한다고 해도, 모든 키를 조사하는 데 120억년 이상의 시간이 걸린다. 방법이 없을까?
>     
>     ⇒ 없다.
>     

---

### bit열의 암호화

> **bit열의 암호화**
> 
> - 배타적 논리합(exclusive-or)연산 사용
>     - 암호화
>         
>         
>         | 평문 | 1 | 0 | 0 | 1 | 1 | 0 | 0 | 0 | 1 | 1 | 1 | 0 |
>         | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
>         | 키 | 1 | 1 | 0 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 1 |
>         | 암호문 | 0 | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 1 |
>     - 해독
>         
>         
>         | 암호문 | 0 | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 1 |
>         | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
>         | 키 | 1 | 1 | 0 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 1 |
>         | 평문 | 1 | 0 | 0 | 1 | 1 | 0 | 0 | 0 | 1 | 1 | 1 | 0 |

---

## 문자열 압축

### 문자열 정보에 대하여 저장소 크기를 줄이며 정확한 정보를 저장하는 방법은?

> **Run-length encoding 알고리즘**
> 
> - 같은 값이 몇 번 반복되는가를 나타냄으로써 압축
>     
>     
>     | A | B | B | B | B | B | B | B | B | A |
>     | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
>     | A | 1 | B | 8 | A | 1 |  |  |  |  |
> - 이 방법은 이미지 파일포맷 중 BMP 파일포맷의 압축 방법이다..
> - 좀 더 효율적이고 일반적인 압축방법은 없는가?
>     - 있다. 많이 사용하는 알고리즘으로 허프만 코딩 알고리즘이 있다.

---
