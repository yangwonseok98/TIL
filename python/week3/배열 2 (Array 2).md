# 배열 2 (Array 2)

---

## INDEX

- 배열 : 2차원 배열
- 부분집합 생성
- 바이너리 서치 (Binary Search)
- 선택 정렬 (Selection Sort)
- 셀렉션 알고리즘 (Selection Algorithm)

---

## 2차원 배열

> **2차원 배열의 선언**
> 
> - 1차원 List를 묶어 놓은 List
> - 2차원 이상의 다차원 List는 차원에 따라 Index를 선언
> - 2차원 List의 선언 : 세로길이(행의 개수), 가로길이(열의 개수) 를 필요로 함
> - Python 에서는 데이터 초기화를 통해 변수선언과 초기화가 가능함
>     
>     
>     `arr = [[0, 1, 2, 3], [4, 5, 6, 7]] #2행 4열의 2차원 List`
>     
>     **List arr**
>     
>     | 0 | 1 | 2 | 3 |
>     | --- | --- | --- | --- |
>     | 4 | 5 | 6 | 7 |

> **[참고]**
> 
> 
> 1.
> 
> input:
> 
> 3
> 
> 1 2 3
> 
> 4 5 6
> 
> 7 8 9
> 
> code:
> 
> ```python
> N = int(input())
> arr = [list(map(int, input().split())) for _ in range(N)]
> ```
> 
> 2.
> 
> input:
> 
> 3
> 
> 123
> 
> 456
> 
> 789
> 
> code:
> 
> ```python
> N = int(input())
> arr = [list(map(int, input())) for _ in range(N)]
> ```
> 

> **2차원 배열의 접근**
> 
> - 배열 순회 : $n\times m$ 배열의 모든 원소를 빠짐없이 조사하는 방법
>     - 행 우선 순회
>         
>         ```python
>         arr = [[0, 1, 2, 3], [4, 5, 6, 7]]
>         n = len(arr)
>         m = len(arr[0])
>         #i 행의 좌표
>         #j 열의 좌표
>         for i in range(n):
>             for j in range(m):
>                 print(arr[i][j], end=' ')
>         #0 1 2 3 4 5 6 7
>         ```
>         
>     - 열 우선 순회
>         
>         ```python
>         arr = [[0, 1, 2, 3], [4, 5, 6, 7]]
>         n = len(arr)
>         m = len(arr[0])
>         #i 행의 좌표
>         #j 열의 좌표
>         for j in range(m):
>             for i in range(n):
>                 print(arr[i][j], end=' ')
>         #0 4 1 5 2 6 3 7
>         ```
>         
>     - 지그재그 순회
>         
>         
>         ```python
>         arr = [[0, 1, 2, 3], [4, 5, 6, 7]]
>         n = len(arr)
>         m = len(arr[0])
>         #i 행의 좌표
>         #j 열의 좌표
>         for i in range(n):
>             for j in range(m):
>                 print(arr[i][j-(2 * j - m + 1) * (i % 2)], end=' ')
>         #0 1 2 3 7 6 5 4
>         ```
>         
> 
> - 델타를 이용한 2차 배열 탐색
>     - 2차 배열의 한 좌표에서 4방향의 인접 배열 요소를 탐색하는 방법
>         
>         ```python
>         arr = [[0, 1, 2, 3], [4, 5, 6, 7]]
>         n = len(arr)
>         m = len(arr[0])
>         dr = [1, -1, 0, 0]
>         dc = [0, 0, 1, -1]
>         visited = [[False for j in range(m)]for i in range(n)]
>         #i 행의 좌표
>         #j 열의 좌표
>         for i in range(n):
>             for j in range(m):
>                 if not visited[i][j]:
>                     print(arr[i][j], end=' ')
>                     visited[i][j] = True
>                 for k in range(4):
>                     nr = i + dr[k]
>                     nc = j + dc[k]
>                     if nr >= 0 and nr < n and nc >= 0 and nc < m and not visited[nr][nc]:
>                         print(arr[nr][nc], end=' ')
>                         visited[nr][nc] = True
>         ```
>         
> - 전치 행렬
>     
>     ```python
>     arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
>     n = len(arr)
>     m = len(arr[0])
>     t_arr = [arr[i][:] for i in range(n)]
>     #i 행의 좌표
>     #j 열의 좌표
>     for i in range(n):
>         for j in range(m):
>             if i < j:
>                 t_arr[i][j] , t_arr[j][i] = t_arr[j][i], t_arr[i][j]
>     print(t_arr)
>     ```
>     

> **<연습문제 1>**
> 
> - $5\times 5$ 2차원 배열에 무작위로 25개의 숫자로 초기화 한 후
> - 25개의 각 요소에 대해서 그 요소와 이웃한 요소와의 차의 절대값의 합을 구하시오
> - 25개의 요소에 대해서 모두 조사하여 총합을 구하시오
> - 벽에 있는 요소는 이웃한 요소가 없을 수 있음을 주의하시오
> 
> ```python
> import random
> import pprint
> 
> print = pprint.pprint
> dr = [0, 0, 1, -1]
> dc = [1, -1, 0, 0]
> 
> N = 5
> arr = [[random.randint(1, 100) for i in range(N)] for j in range(N)]
> res_arr = [[0 for i in range(N)]for j in range(N)]
> 
> for i in range(N):
>     for j in range(N):
>         res = 0
>         for k in range(4):
>             nr = i + dr[k]
>             nc = j + dc[k]
>             if nr >= 0 and nr < N and nc >= 0 and nc < N:
>                 res += abs(arr[i][j] - arr[nr][nc])
>         res_arr[i][j] = res
> 
> print(arr)
> print(res_arr) 
> ```
> 

---

## 부분집합 생성

> **부분집합 합(Subset Sum) 문제**
> 
> - 유한 개의 정수로 이루어진 집합이 있을 때, 이 집합의 부분집합 중에서 그 집합의 원소를 모두 더한 값이 0이 되는 경우가 있는지를 알아내는 문제
> - 예를 들어, [-7, -3, -2, 5, 8]라는 집합이 있을 때, [-3, -2, 5]는 이 집합의 부분집합이면서 (-3)+(-2)+5 = 0 이므로 이 경우의 답은 참이 된다.

> **부분집합 생성하기**
> 
> - 완전검색 기법으로 부분집합 합 문제를 풀기 위해서는, 우선 집합의 모든 부분집합을 생성한 후에 각 부분집합의 합을 계산해야 한다.
> - 주어진 집합의 부분집합을 생성하는 방법에 대해서 생각해보자.
> - 부분 집합의 수
>     - 집합의 원소가 n개일 때, 공집합을 포함한 부분집합의 수는 $2^{n}$개 이다.
>     - 이는 각 원소를 부분집합에 포함시키거나 포함시키지 않는 2가지 경우를 모든 원소에 적용한 경우의 수와 같다.
>     - 예) {1, 2, 3, 4} ⇒ $2^{4}$ = 16가지
> - 각 원소가 부분집합에 포함되었는지를 loop 이용하여 확인하고 부분집합을 생성하는 방법
>     
>     ```python
>     bit = [0, 0, 0, 0]
>     for i in range(2):
>         bit[0] = i
>         for j in range(2):
>             bit[1] = j
>             for k in range(2):
>                 bit[2] = k
>                 for l in range(2):
>                     bit[3] = l
>                     print(*bit)
>     ```
>     
> - 비트 연산자
>     
>     
>     | & | 비트 단위로 AND 연산을 한다. |
>     | --- | --- |
>     | | | 비트 단위로 OR 연산을 한다. |
>     | << | 피연산자의 비트 열을 왼쪽으로 이동시킨다. |
>     | >> | 피연산자의 비트 열을 오른쪽으로 이동시킨다. |
> - << 연산자
>     - 1 << n : $2^{n}$ 즉, 원소가 n개일 경우의 모든 부분집합의 수를 의미한다.
> - & 연산자
>     - i & (1<<j) : i의 j번째 비트가 1인지 아닌지를 검사한다.
> - 보다 간결하게 부분집합을 생성하는 방법
>     
>     ```python
>     arr = [3, 6, 7, 1, 5, 4]
>     
>     n = len(arr)
>     list_of_subset = [[] for i in range(1 << n)]
>     for i in range(1 << n):
>         tmp = []
>         for j in range(n):
>             if i & (1 << j):
>                 tmp.append(arr[j])
>         list_of_subset[i] = tmp[:]
>     print(list_of_subset)
>     ```
>     
> - 부분집합 합 문제 구현하기
>     - 그럼 실제로 10개의 정수를 입력 받아 부분집합의 합이 0이 되는 것이 존재하는지를 계산하는 함수를 작성해보자.
>     
>     ```python
>     arr = list(map(int, input().split()))
>     n = len(arr)
>     
>     res = False
>     for i in range(1 << n):
>         tmp = 0
>         for j in range(n):
>             if i & (1 << j):
>                tmp += arr[j]
>         if i != 0 and tmp == 0:
>             res = True
>             break
>     print(res)
>     ```
>     

---

## 바이너리 서치 (Binary Search)

> **검색(Search)**
> 
> - 저장되어 있는 자료 중에서 원하는 항목을 찾는 작업
> - 목적하는 탐색 키를 가진 항목을 찾는 것
>     - 탐색 키(Search key) : 자료를 구별하여 인식할 수 있는 키
> - 검색의 종류
>     - 순차 검색(sequential search)
>     - 이진 검색(binary search)
>     - 해쉬(hash)

### 순차 검색

> **순차 검색(sequential search)**
> 
> - 일렬로 되어 있는 자료를 순서대로 검색하는 방법
>     - 가장 간단하고 직관적인 검색 방법
>     - 배열이나 연결 리스트 등 순차구조로 구현된 자료구조에서 원하는 항목을 찾을 때 유용함
>     - 알고리즘이 단순하여 구현이 쉽지만, 검색 대상의 수가 많은 경우에는 수행시간이 급격히 증가하여 비효율적임
> - 2가지 경우
>     - 정렬되어 있지 않은 경우
>     - 정렬되어 있는 경우

> **정렬되어 있지 않은 경우**
> 
> - 검색 과정
>     - 첫 번째 원소부터 순서대로 검색 대상과 키 값이 같은 원소가 있는지 비교하며 찾는다.
>     - 키 값이 동일한 원소를 찾으면 그 원소의 인덱스를 반환한다.
>     - 자료구조의 마지막에 이를 때까지 검색 대상을 찾지 못하면 검색 실패
> - 예) 2를 검색 하는 경우
>     
>     [4, 9, 11, 23, 2, 19, 7]
>     
>     <검색 과정>
>     
>     1. [4, 9, 11, 23, 2, 19, 7]
>     2. [4, 9, 11, 23, 2, 19, 7]
>     3. [4, 9, 11, 23, 2, 19, 7]
>     4. [4, 9, 11, 23, 2, 19, 7]
>     5. [4, 9, 11, 23, 2, 19, 7] ⇒ **검색 성공!!**
> 
> - 예) 8을 검색 하는 경우
>     
>     [4, 9, 11, 23, 2, 19, 7]
>     
>     <검색 과정>
>     
>     1. [4, 9, 11, 23, 2, 19, 7]
>     2. [4, 9, 11, 23, 2, 19, 7]
>     3. [4, 9, 11, 23, 2, 19, 7]
>     4. [4, 9, 11, 23, 2, 19, 7]
>     5. [4, 9, 11, 23, 2, 19, 7] 
>     6. [4, 9, 11, 23, 2, 19, 7]
>     7. [4, 9, 11, 23, 2, 19, 7] ⇒ **검색 실패!!**
> - 찾고자 하는 원소의 순서에 따라 비교회수가 결정됨
>     - 첫 번째 원소를 찾을 때는 1번 비교, 두 번째 원소를 찾을 때는 2번 비교..
>     - 정렬되지 않은 자료에서의 순차 검색의 평균 비교 회수
>         - = (1/n) * (1+2+3+…+n) = (n+1)/2
>     - 시간 복잡도 : O(n)
> - 구현 예
>     
>     ```python
>     def sequential_search(arr, len_a, key):
>         i = 0
>         while i < len_a:
>             if arr[i] == key:
>                 return i
>             i += 1
>         return -1
>     
>     print(sequential_search([4, 9, 11, 23, 2, 19, 7], 7, 2))
>     print(sequential_search([4, 9, 11, 23, 2, 19, 7], 7, 8))
>     # 4
>     # -1
>     ```
>     

> **정렬되어 있는 경우**
> 
> - 검색 과정
>     - 자료가 오름차순으로 정렬된 상태에서 검색을 실시한다고 가정하자.
>     - 자료를 순차적으로 검색하면서 키 값을 비교하여, 원소의 키 값이 검색 대상의 키 값보다 크면 찾는 원소가 없다는 것이므로 더 이상 검색을 하지 않고 검색을 종료한다.
> - 예) 11을 검색하는 경우
>     
>     [2, 4, 7, 9, 11, 19, 23]
>     
>     <검색 과정>
>     
>     1. [2, 4, 7, 9, 11, 19, 23]
>     2. [2, 4, 7, 9, 11, 19, 23]
>     3. [2, 4, 7, 9, 11, 19, 23]
>     4. [2, 4, 7, 9, 11, 19, 23]
>     5. [2, 4, 7, 9, 11, 19, 23] ⇒ **검색 성공!!**
> 
> - 예) 10을 검색하는 경우
>     
>     [2, 4, 7, 9, 11, 19, 23]
>     
>     <검색 과정>
>     
>     1. [2, 4, 7, 9, 11, 19, 23]
>     2. [2, 4, 7, 9, 11, 19, 23]
>     3. [2, 4, 7, 9, 11, 19, 23]
>     4. [2, 4, 7, 9, 11, 19, 23]
>     5. [2, 4, 7, 9, 11, 19, 23] ⇒ **검색 실패!!**
>         
>         **검색 종료**
>         
> - 찾고자 하는 원소의 순서에 따라 비교회수가 결정됨
>     - 정렬이 되어있으므로, 검색 실패를 반환하는 경우 평균 비교 회수가 반으로 줄어든다.
>     - 시간 복잡도 : O(n)
> - 구현 예
>     
>     ```python
>     def sequentialSearch2(a, n, key):
>         i = 0
>         while i < n and a[i] < key:
>             i += 1
>         if i < n and a[i] == key:
>             return i
>         else:
>             return -1
>     
>     arr = [2, 4, 7, 9, 11, 19, 23]
>     print(sequentialSearch2(arr, len(arr)-1, 11))
>     print(sequentialSearch2(arr, len(arr)-1, 10))
>     ```
>     

---

### 이진 검색(Binary Search)

> **이진 검색(Binary Search)**
> 
> - 자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법
>     - 목적 키를 찾을 때까지 이진 검색을 순환적으로 반복 수행함으로써 검색 범위를 반으로 줄여가면서 보다 빠르게 검색을 수행함
> - 이진 검색을 하기 위해서는 자료가 정렬된 상태여야 한다.
> 
> - 검색 과정
>     - 자료의 중앙에 있는 원소를 고른다
>     - 중앙 원소의 값과 찾고자 하는 목표 값을 비교한다
>     - 목표값이 중앙 원소의 값보다 작으면 자료의 왼쪽 반에 대해서 새로 검색을 수행하고, 크다면 자료의 오른쪽 반에 대해서 새로 검색을 수행한다.
>     - 찾고자 하는 값을 찾을 때까지 1~3의 과정을 반복한다.
> 
> - 예) 이진 검색으로 7을 찾는 경우
>     
>     
>     | 2 | 4 | 7 | 9 | 11 | 19 | 23 |
>     | --- | --- | --- | --- | --- | --- | --- |
>     
>     | 2 | 4 | 7 | 9 | 11 | 19 | 23 |
>     | --- | --- | --- | --- | --- | --- | --- |
>     
>     | 2 | 4 | 7 | 9 | 11 | 19 | 23 |
>     | --- | --- | --- | --- | --- | --- | --- |
>     
>     **검색 성공 !!**
>     
> - 예) 이진 검색으로 20을 찾는 경우
>     
>     
>     | 2 | 4 | 7 | 9 | 11 | 19 | 23 |
>     | --- | --- | --- | --- | --- | --- | --- |
>     
>     | 2 | 4 | 7 | 9 | 11 | 19 | 23 |
>     | --- | --- | --- | --- | --- | --- | --- |
>     
>     | 2 | 4 | 7 | 9 | 11 | 19 | 23 |
>     | --- | --- | --- | --- | --- | --- | --- |
>     
>     **검색 실패 !!**
>     

> **이진 검색 알고리즘**
> 
> - 구현
>     - 검색 범위의 시작점과 종료점을 이용하여 검색을 반복 수행한다.
>     - 이진 검색의 경우, 자료에 삽입이나 삭제가 발생했을 때 배열의 상태를 항상 정렬 상태로 유지하는 추가 작업이 필요하다.
>     
>     ```python
>     def binarySearch(a, N, key):
>         start = 0
>         end = N-1
>         while start <= end:
>             mid = (start + end) // 2
>             if a[mid] == key:
>                 return True
>             elif a[mid] > key:
>                 end = mid-1
>             else:
>                 start = mid + 1
>         return False
>     
>     arr = [2, 4, 7, 9, 11, 9, 23]
>     print(binarySearch(arr, len(arr)-1, 7))
>     print(binarySearch(arr, len(arr)-1, 20))
>     ```
>     
> 
> - 재귀 함수 이용
>     - 아래와 같이 재귀 함수를 이용하여 이진 검색을 구현할 수도 있다.
>     - 재귀 함수에 대해서는 나중에 더 자세히 배우도록 한다.
>     
>     ```python
>     def binarySearch(a, s, e, key):
>         if s > e:
>             return False
>         else:
>             mid = (s + e) // 2
>             if a[mid] == key:
>                 return True
>             elif a[mid] > key:
>                 return binarySearch(a, s, mid-1, key)
>             else:
>                 return binarySearch(a, mid+1, e, key)
>     
>     arr = [2, 4, 7, 9, 11, 9, 23]
>     print(binarySearch(arr, 0, len(arr)-1, 7))
>     print(binarySearch(arr, 0, len(arr)-1, 20))
>     ```
>     

---

## 선택 정렬 (Selection Sort)

### 인덱스

> **인덱스**
> 
> - 인덱스라는 용어는 Database에서 유래했으며, 테이블에 대한 동작 속도를 높여주는 자료 구조를 일컫는다. Database 분야가 아닌 곳에서는 Look up table등의 용어를 사용하기도 한다.
> - 인덱스를 저장하는데 필요한 디스크 공간은 보통 테이블을 저장하는데 필요한 디스크 공간보다 작다. 왜냐하면 보통 인덱스는 키-필드만 갖고 있고, 테이블의 다른 세부 항목들은 갖고 있지 않기 때문이다.
> - 배열을 사용한 인덱스
>     - 대량의 데이터를 매번 정렬하면, 프로그램의 반응은 늘려질 수 밖에 없다. 이러한 대량의 데이터의 성능 저하 문제를 해결하기 위해 배열 인덱스를 사용할 수 있다.

> **다음 예에서 원본 데이터 배열과 별개로, 배열 인덱스를 추가한 예를 보여주고 있다.**
> 
> - 원본 데이터에 데이터가 삽입 될 경우 상대적으로 크기가 작은 인덱스 배열을 정렬하기 때문에 속도가 빠르다.
>     
>     **id 인덱스 배열**
>     
>     | array index | id | original index |
>     | --- | --- | --- |
>     | 0 | 1041 | 0 |
>     | 1 | 7334 | 2 |
>     | 2 | 19467 | 1 |
>     | 3 | 27500 | 3 |
>     
>     **원본 데이터 배열**
>     
>     | array index | id | name | number |
>     | --- | --- | --- | --- |
>     | 0 | 1041 | Melissa | 428-849-0471 |
>     | 1 | 19467 | barbara | 672-511-7155 |
>     | 2 | 7334 | Florence | 586-112-3241 |
>     | 3 | 27500 | shara | 459-729-8167 |

### 선택 정렬

> **포켓볼 순서대로 정렬하기**
> 
> - 흩어진 당구공을 정리한다고 생각하자. 어떻게 하겠는가?
> - 많은 사람들은 당구대 위에 있는 공 중 가장 작은 숫자의 공부터 골라서 차례대로 정리할 것이다. 이것이 바로 선택 정렬이다.

> **선택정렬(Selection Sort)**
> 
> - 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식
>     - 뒤에 살펴볼 셀렉션 알고리즘을 전체 자료에 적용한 것이다.
> - 정렬 과정
>     - 주어진 리스트 중에서 최소값을 찾는다.
>     - 그 값을 리스트의 맨 앞에 위치한 값과 교환한다.
>     - 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정을 반복한다.
> - 시간 복잡도
>     - O(n^2)

> **선택 정렬 과정**
> 
> - 정렬 과정
>     1. 주어진 리스트에서 최소값을 찾는다.
>     
>     | 64 | 25 | 10 | 22 | 11 |
>     | --- | --- | --- | --- | --- |
>     1. 리스트의 맨 앞에 위치한 값과 교환한다.
>     
>     | 10 | 25 | 64 | 22 | 11 |
>     | --- | --- | --- | --- | --- |
>     1. 미정렬 리스트에서 최소값을 찾는다.
>     
>     | 10 | 25 | 64 | 22 | 11 |
>     | --- | --- | --- | --- | --- |
>     1. 리스트의 맨 앞에 위치한 값과 교환한다.
>     
>     | 10 | 11 | 64 | 22 | 25 |
>     | --- | --- | --- | --- | --- |
>     1. 미정렬 리스트에서 최소값을 찾는다.
>     
>     | 10 | 11 | 64 | 22 | 25 |
>     | --- | --- | --- | --- | --- |
>     1. 리스트의 맨 앞에 위치한 값과 교환한다.
>     
>     | 10 | 11 | 22 | 64 | 25 |
>     | --- | --- | --- | --- | --- |
>     1. 미정렬 리스트에서 최소값을 찾는다.
>     
>     | 10 | 11 | 22 | 64 | 25 |
>     | --- | --- | --- | --- | --- |
>     1. 리스트의 맨 앞에 위치한 값과 교환한다.
>     
>     | 10 | 11 | 22 | 25 | 64 |
>     | --- | --- | --- | --- | --- |
>     - 미정렬원소가 하나 남은 상황에서는 마지막 원소가 가장 큰 값을 갖게 되므로, 실행을 종료하고 선택 정렬이 완료된다.

### 선택 정렬 알고리즘

> **선택정렬 알고리즘**
> 
> 
> ```python
> def selectionSort(a, N):
>     for first_idx in range(N-1):
>         min_idx = first_idx+1
>         for i in range(first_idx+1, N):
>             if a[min_idx] > a[i]:
>                 min_idx = i
>         a[first_idx], a[min_idx] = a[min_idx], a[first_idx]
> 
> arr = [64, 25, 10, 22, 11]
> print(arr)
> selectionSort(arr, len(arr))
> print(arr)
> ```
> 

---

## 셀렉션 알고리즘 (Selection Algorithm)

> **셀렉션 알고리즘 (Selection Algorithm)**
> 
> - 저장되어 있는 자료로부터 k번째로 큰 혹은 작은 원소를 찾는 방법을 셀렉션 알고리즘이라 한다.
>     - 최소값, 최대값 혹은 중간값을 찾는 알고리즘을 의미하기도 한다.
> - 선택 과정
>     - 셀렉션은 아래와 같은 과정을 통해 이루어진다.
>         - 정렬 알고리즘을 이용하여 자료 정렬하기
>         - 원하는 순서에 있는 원소 가져오기

> **일반적인 셀렉션 알고리즘**
> 
> - 아래는 k 번째로 작은 원소를 찾는 알고리즘
>     - 1번부터 k번째까지 작은 원소들을 찾아 배열의 앞쪽으로 이동시키고, 배열의 k번째를 반환한다.
>     - k가 비교적 작을 때 유용하며 O(kN)의 수행 시간이 필요로 한다.
>         
>         ```python
>         def select(arr, k):
>             for i in range(0, k):
>                 min_idx = i
>                 for j in range(i+1, len(arr)):
>                     if arr[min_idx] > arr[j]:
>                         min_idx = j
>                 arr[i], arr[min_idx] = arr[min_idx], arr[i]
>             return arr[k-1]
>         
>         arr = [64, 25, 10, 22, 11]
>         print(select(arr, 4))
>         ```
>         

---

## 정렬 알고리즘 비교

> **정렬 알고리즘 비교**
> 
> - 학습한 정렬 알고리즘의 특성을 다른 정렬들과 비교해보자.
>     
>     
>     | 알고리즘 | 평균 수행시간 | 최악 수행시간 | 알고리즘 기법 | 비고 |
>     | --- | --- | --- | --- | --- |
>     | 버블 정렬 | O(n^2) | O(n^2) | 비교와 교환 | 코딩이 가장 손쉽다. |
>     | 카운팅 정렬 | O(n + k) | O(n + k) | 비교환 방식 | n이 비교적 작을 때만 가능하다. |
>     | 선택 정렬 | O(n^2) | O(n^2) | 비교와 교환 | 교환의 회수가 버블, 삽입 정렬보다 작다 |
>     | 퀵 정렬 | O(n log n) | O(n^2) | 분할 정복 | 최악의 경우 O(n^2) 이지만, 평균적으로는 가장 빠르다. |
>     | 삽입 정렬 | O(n^2) | O(n^2) | 비교와 교환 | n개의 개수가 작을 때 효과적이다. |
>     | 병합 정렬 | O(n log n) | O(n log n) | 분할 정복 | 연결 리스트의 경우 가장 효율적인 방식 |

---

## <연습문제3>

> **<연습문제3>**
> 
> - 다음 그림의 왼쪽과 같이 2차 배열을 초기화 한 후 오른쪽 2차 배열과 같이 정렬하여 2차 배열 형태로 출력하시오
>     
>     
>     | 9 | 20 | 2 | 18 | 11 |
>     | --- | --- | --- | --- | --- |
>     | 19 | 1 | 25 | 3 | 21 |
>     | 8 | 24 | 10 | 17 | 7 |
>     | 15 | 4 | 16 | 5 | 6 |
>     | 12 | 13 | 22 | 23 | 14 |
>     
>     | 1 | 2 | 3 | 4 | 5 |
>     | --- | --- | --- | --- | --- |
>     | 16 | 17 | 18 | 19 | 6 |
>     | 15 | 24 | 25 | 20 | 7 |
>     | 14 | 23 | 22 | 21 | 8 |
>     | 13 | 12 | 11 | 10 | 9 |
>     
>     ```python
>     def print_new_arr(arr, N):
>         max_r = N-1
>         max_c = N-1
>         min_r = 1
>         min_c = 0
>         d_dir = [[0, 1], [1, 0], [0, -1], [-1, 0]]
>         whole_arr = []
>         for sub_arr in arr:
>             whole_arr.extend(sub_arr)
>         for start_idx in range(0, len(whole_arr)-1):
>             min_idx = start_idx
>             for i in range(start_idx+1, len(whole_arr)):
>                 if whole_arr[min_idx] > whole_arr[i]:
>                     min_idx = i
>             whole_arr[start_idx], whole_arr[min_idx] = whole_arr[min_idx], whole_arr[start_idx]
>         new_arr = [[0 for i in range(N)] for j in range(N)]
>         now_r = 0
>         now_c = 0
>         dir_idx = 0
>         for i in range(len(whole_arr)):
>             new_arr[now_r][now_c] = whole_arr[i]
>             if i != 0:
>                 if dir_idx == 0 and now_c == max_c:
>                     max_c -= 1
>                     dir_idx = (dir_idx + 1) % 4
>                 elif dir_idx == 1 and now_r == max_r:
>                     max_r -= 1
>                     dir_idx = (dir_idx + 1) % 4
>                 elif dir_idx == 2 and now_c == min_c:
>                     min_c += 1
>                     dir_idx = (dir_idx + 1) % 4
>                 elif dir_idx == 3 and now_r == min_r:
>                     min_r += 1
>                     dir_idx = (dir_idx + 1) % 4
>             now_r += d_dir[dir_idx][0]
>             now_c += d_dir[dir_idx][1]
>             
>         for sub_new_arr in new_arr:
>             print(sub_new_arr)
>     
>     arr = [[9, 20, 2, 18, 11],
>            [19, 1, 25, 3, 21],
>            [8, 24, 10, 17, 7],
>            [15, 4, 16, 5, 6],
>            [12, 13, 22, 23, 14]]
>     print_new_arr(arr, len(arr))
>     ```
>