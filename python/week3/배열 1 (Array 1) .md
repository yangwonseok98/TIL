# 배열 1 (Array 1)

## INDEX

> **INDEX**
> 
> - 알고리즘
> - 배열
> - 버블 정렬(Bubble sort)
> - 카운팅 정렬(Counting Sort)
> - 완전 검색
> - 그리디(Greedy Algorithm)

---

## 알고리즘

> **알고리즘**
> 
> - (명) 알고리즘 : 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법이다. 주로 컴퓨터용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법을 말한다.
> - 간단하게 다시 말하면 어떠한 문제를 해결하기 위한 절차라고 볼 수 있다.
> - 예를 들어 1부터 100까지의 합을 구하는 문제를 생각해 보자.
> - 컴퓨터 분야예서 알고리즘을 표현 하는 방법은 크게 두 가지
>     - 의사코드 (슈도코드, Pseudocode)와 순서도
> - APS 과정의 목표 중의 하나는 보다 좋은 알고리즘을 이해하고 활용하는 것이다.
> - 무엇이 좋은 알고리즘인가?
>     1. 정확성 : 얼마나 정확하게 동작하는가
>     2. 작업량 : 얼마나 적은 연산으로 원하는 결과를 얻어내는가
>     3. 메모리 사용량 : 얼마나 적은 메모리를 사용하는가
>     4. 단순성 : 얼마나 단순한가
>     5. 최적성 : 더 이상 개선할 여지없이 최적화되었는가
> - 주어진 문제를 해결하기 위해 여러 개의 다양한 알고리즘이 가능
>     
>     ⇒ 어떤 알고리즘을 사용해야 하는가?
>     
> - 알고리즘의 성능 분석 필요
>     - 많은 문제에서 성능 분석의 기준으로 알고리즘의 작업량을 비교한다.
> - 예 : 1부터 100까지 합을 구하는 문제
>     - 알고리즘 1 : 1 + 2 + … + 100 = 5050 ⇒ 100번의 연산
>     - 알고리즘 2 : $\frac{100 \times (1+100)}{2} = 5050$ ⇒ 3번의 연산
> - 알고리즘의 작업량을 표현할 때 시간복잡도로 표현한다.
> - 시간 복잡도(Time Complexity)
>     - 실제 걸리는 시간을 측정
>     - 실행되는 명령문의 개수를 계산
>         - 알고리즘 1 : 2n + 1
>         - 알고리즘 2 : 3
> - 시간 복잡도 = 빅-오(O) 표기법
>     - 빅-오 표기법 (Big-Oh Notation)
>     - 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시
>     - 계수(Coefficient)는 생략하여 표시
>     - 예를 들어
>         - O(3n + 2) = O(3n) = O(n)
>         - O(2n^2 + 10n + 100) = O(n^2)
>         - O(4) = O(1)
>     - n 개의 데이터를 입력 받아 저장한 후 각 데이터에 1씩 증가시킨 후 각 데이터를 화면에 출력하는 알고리즘의 시간복잡도는 어떻게 되나?
>         
>         ⇒ O(n)
>         
> - 요소 수가 증가함에 따라 시간복잡도에 따른 연산수 차이가 매우 크다.

---

## 배열

> **배열의 필요성**
> 
> - 프로그램 내에서 여러 개의 변수가 필요할 때, 일일이 다른 변수명을 이용하여 자료에 접근하는 것은 매우 비효율적일 수 있다.
> - 배열을 사용하면 하나의 선언을 통해서 둘 이상의 변수를 선언할 수 있다.
> - 단순히 다수의 변수 선언을 의미하는 것이 아니라, 다수의 변수로는 하기 힘든 작업을 배열을 활용해 쉽게 할 수 있다.

---

## 1차원 배열

> **1차원 배열의 선언**
> 
> - 별도의 선언 방법이 없으면 변수에 처음 값을 할당할 때 생성
> - 이름 : 프로그램에서 사용할 배열의 이름
>     
>     `arr = list()` , `arr = []` (1차원 배열 선언의 예)
>     
>     `arr = [1, 2, 3]` , `arr = [0]*10` 
>     

> **1차원 배열의 접근**
> 
> - `Arr[0] = 10 # 배열 arr의 0번 원소에 0을 저장하라`
> - `Arr[idx] = 20 # 배열 arr의 idx번 원소에 20을 저장하라`

---

## 연습문제

> **배열 활용 예제 : Gravity**
> 
> - 상자들이 쌓여있는 방이 있다. 방이 오른쪽으로 90도 회전하여 상자들이 중력의 영향을 받아 낙하한다고 할 때, 낙차가 가장 큰 상자를 구하여 그 낙차를 리턴하는 프로그램을 작성하시오.
> - 중력은 회전이 완료된 후 적용된다.
> - 상자들은 모두 한쪽 벽면에 붙여진 상태로 쌓여 2차원의 형태를 이루며 벽에서 떨어져서 쌓은 상자는 없다.
> - 방의 가로길이는 항상 100이며, 세로 길이도 항상 100이다.
> - 즉, 상자는 최소 0, 최대 100 높이로 쌓을 수 있다.
>     
>     ```python
>     def f1():
>         global arr
>         max_height = max(arr)
>         last_idx = [-1 for i in range(max_height+1)]
>         res = 0
>         len_arr = len(arr)
>         i = 0
>         while i < len_arr:
>             tmp = arr[i]
>             for j in range(tmp+1):
>                 if last_idx[j] != -1:
>                     drop = i - last_idx[j]
>                     if drop > res:
>                         res = drop
>                 last_idx[j] = i
>             i += 1
>         for l in last_idx:
>             if l != -1:
>                 if res < i-l:
>                     res = i-l
>         return res
>     
>     arr = [7, 4, 2, 0, 0, 6, 0, 7, 0]
>     print(f1())
>     ```
>     

---

## 정렬

> **정렬**
> 
> - 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값(오름차순 : ascending), 혹은 그 반대의 순서대로(내림차순 : descending) 재배열 하는 것
> - 키
>     - 자료를 정렬하는 기준이 되는 특정 값
>         - 서류를 번호대로 정렬하기
>         - 카드를 번호대로 정렬하기

> **정렬의 종류**
> 
> - 대표적인 정렬 방식의 종류
>     - 버블 정렬(Bubble Sort)
>     - 카운팅 정렬(Counting Sort)
>     - 선택 정렬(Selection Sort)
>     - 퀵 정렬(Quick Sort)
>     - 삽입 정렬(Insertions sort)
>     - 병합 정렬(Merge Sort)
> - APS 과정을 통해 자료구조와 알고리즘을 학습하면서 다양한 형태의 정렬을 학습하게 된다.

> **버블 정렬(Bubble sort)**
> 
> - 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
> - 정렬 과정
>     - 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동한다.
>     - 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다.
>     - 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품 모양과 같다고 하여 버블 정렬이라고 한다.
> - 시간 복잡도
>     - O(n^2)
> - 버블 정렬 과정
>     - [55, 7, 78, 12, 42]를 버블 정렬하는 과정(오름차순)
>         
>         
>         | 55 | 7 | 78 | 12 | 42 |
>         | --- | --- | --- | --- | --- |
>         | 7 | 55 | 78 | 12 | 42 |
>         | 7 | 55 | 78 | 12 | 42 |
>         | 7 | 55 | 12 | 78 | 42 |
>         | 7 | 55 | 12 | 42 | 78 |
>         
>         | 7 | 55 | 12 | 42 | 78 |
>         | --- | --- | --- | --- | --- |
>         | 7 | 55 | 12 | 42 | 78 |
>         | 7 | 12 | 55 | 42 | 78 |
>         | 7 | 12 | 42 | 55 | 78 |
>         
>         | 7 | 12 | 42 | 55 | 78 |
>         | --- | --- | --- | --- | --- |
>         | 7 | 12 | 42 | 55 | 78 |
>         | 7 | 12 | 42 | 55 | 78 |
>         
>         | 7 | 12 | 42 | 55 | 78 |
>         | --- | --- | --- | --- | --- |
>         | 7 | 12 | 42 | 55 | 78 |
>         
>         | 7 | 12 | 42 | 55 | 78 |
>         | --- | --- | --- | --- | --- |
> - 알고리즘
>     
>     ```python
>     def swap(left_idx):
>         global arr
>         arr[left_idx], arr[left_idx + 1] = arr[left_idx+1], arr[left_idx]
>     
>     def bubble_sort(reverse=False):
>         global arr
>         len_arr = len(arr)
>         for last_idx in range(len_arr-1, 0, -1):
>             for start_idx in range(0, last_idx):
>                 if arr[start_idx] > arr[start_idx+1]:
>                     swap(start_idx)
>         if reverse:
>             arr = arr[::-1]
>     
>     arr = [55, 7, 78, 12, 42]
>     bubble_sort()
>     print(arr)
>     
>     arr = [55, 7, 78, 12, 42]
>     bubble_sort(reverse=True)
>     print(arr)
>     ```
>     
>     ```c
>     #include <stdio.h>
>     void bubble_sort(int *arr, int len_arr, short reverse){
>         for(int i=len_arr-1;i>0;i--){
>             for(int j=0;j<i;j++){
>                 if(reverse){
>                     if (arr[j] < arr[j+1]){
>                         int tmp = arr[j];
>                         arr[j] = arr[j+1];
>                         arr[j+1] = tmp;
>                     }
>                 }
>                 else{
>                     if (arr[j] > arr[j+1]){
>                         int tmp = arr[j];
>                         arr[j] = arr[j+1];
>                         arr[j+1] = tmp;
>                     }
>                 }
>             }
>         }
>     }
>     
>     int main() {
>         int arr1[] = {55, 7, 78, 12, 42};
>         bubble_sort(arr1, sizeof(arr1)/sizeof(int), 0);
>         for(int i=0;i<sizeof(arr1)/sizeof(int);i++)
>             printf("%d ",arr1[i]);
>         printf("\n");
>         int arr2[] = {55, 7, 78, 12, 42};
>         bubble_sort(arr2, sizeof(arr2)/sizeof(int), 1);
>         for(int i=0;i<sizeof(arr2)/sizeof(int);i++)
>             printf("%d ",arr2[i]);
>         printf("\n");
>         return 0;
>     }
>     ```
>     

---

## 카운팅 정렬(Counting Sort)

> **카운팅 정렬**
> 
> - 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘
> - 제한 사항
>     - 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능 : 각 항목의 발생 회수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운드들의 배열을 사용하기 때문이다.
>     - 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 한다.
> - 시간 복잡도
>     - O(n+k) : n은 리스트 길이, k는 정수의 최대값
> - 카운팅 정렬 과정
>     
>     DATA : 
>     
>     | 0 | 4 | 1 | 3 | 1 | 2 | 4 | 1 |
>     | --- | --- | --- | --- | --- | --- | --- | --- |
>     
>     COUNTS:
>     
>     | 0 | 0 | 0 | 0 | 0 |
>     | --- | --- | --- | --- | --- |
>     
>     COUNTS:
>     
>     | 1 | 3 | 1 | 1 | 2 |
>     | --- | --- | --- | --- | --- |
>     
>     COUNTS:
>     
>     | 1 | 4 | 5 | 6 | 8 |
>     | --- | --- | --- | --- | --- |

> **카운팅 정렬 알고리즘**
> 
> 
> ```c
> def couting_sort(reverse=False):
>     global arr
>     max_idx, min_idx = max(arr), min(arr)
>     cnt = [0 for i in range(min_idx, max_idx+1)]
>     for element in arr:
>         cnt[element-min_idx] += 1
>     arr = []
>     for i in range(len(cnt)):
>         tmp = cnt[i]
>         while tmp > 0:
>             arr.append(i+min_idx)
>             tmp -= 1
>     if reverse:
>         arr = arr[::-1]
>     return arr
> 
> arr = [55, 7, 78, 12, 42]
> couting_sort()
> print(arr)
> arr = [55, 7, 78, 12, 42]
> couting_sort(reverse=True)
> print(arr)
> ```
> 

---

## 정렬 알고리즘 비교

> **정렬 알고리즘 비교**
> 
> - 학습한 정렬 알고리즘의 특성을 다른 정렬들과 비교해보자.
>     
>     
>     | 알고리즘 | 평균 수행시간 | 최악 수행시간 | 알고리즘 기법 | 비고 |
>     | --- | --- | --- | --- | --- |
>     | 버블 정렬 | O(n^2) | O(n^2) | 비교와 교환 | 코딩이 가장 손쉽다. |
>     | 카운팅 정렬 | O(n + k) | O(n + k) | 비교환 방식 | n이 비교적 작을 때만 가능하다. |
>     | 선택 정렬 | O(n^2) | O(n^2) | 비교와 교환 | 교환의 회수가 버블, 삽입 정렬보다 작다 |
>     | 퀵 정렬 | O(n log n) | O(n^2) | 분할 정복 | 최악의 경우 O(n^2) 이지만, 평균적으로는 가장 빠르다. |
>     | 삽입 정렬 | O(n^2) | O(n^2) | 비교와 교환 | n개의 개수가 작을 때 효과적이다. |
>     | 병합 정렬 | O(n log n) | O(n log n) | 분할 정복 | 연결 리스트의 경우 가장 효율적인 방식 |

---

## Baby-gin Game

> **설명**
> 
> - 0~9 사이의 숫자 카드에서 임의의 카드 6장을 뽑았을 때, 3장의 카드가 연속적인 번호를 갖는 경우를 run이라 하고, 3장의 카드가 동일한 번호를 갖는 경우를 triplet이라고 한다.
> - 그리고, 6장의 카드가 run과 triplet로만 구성된 경우를 baby-gin으로 부른다
> - 6자리의 숫자를 입력 받아 baby-gin 여부를 판단하는 프로그램을 작성하라.

> **입력 예**
> 
> - 667767은 두 개의 triplet이므로 baby-gin
> - 054060은 한 개의 run과 한 개의 triplet이므로 역시 baby-gin이다.
> - 101123은 한 개의 triplet가 존재하나, 023이 run이 아니므로 baby-gin 이 아니다.
>     
>     (123을 run으로 사용하더라도 011이 run이나 triplet가 아님)
>     
> - 6자리의 숫자를 입력 받아 어떻게 Baby-gin 여부를 찾을 것인가?

---

## 완전 검색(Exaustive Search)

> **완전 검색(Exaustive Search)**
> 
> - 완전 검색 방법은 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해 보고 확인하는 기법이다.
> - Brute-force 혹은 generate-and-test 기법이라고도 불리운다.
> - 모든 경우의 수를 테스트한 후, 최종 해법을 도출한다.
> - 일반적으로 경우의 수가 상대적으로 작을 때 유용하다.

> **완전 검색으로 시작하라**
> 
> - 모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 작다.
> - 자격검정평가 등에서 주어진 문제를 풀 때, 우선 완전 검색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직하다.

> **완전 검색을 활용한 Baby-gin 접근**
> 
> - 고려할 수 있는 모든 경우의 수 생성하기
>     - 6개의 숫자로 만들 수 있는 모든 숫자 나열 (중복 포함)
> - 해답 테스트하기
>     - 앞의 3자리와 뒤의 3자리를 잘라, run와 triplet 여부를 테스트하고 최종적으로 baby-gin을 판단한다.

> **순열(Permutation)**
> 
> - 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
> - 서로 다른 n개 중 r개를 택하는 순열은 아래와 같이 표현한다.
>     - $_nP_r$
> - 그리고 $_nP_r$은 다음과 같은 식이 성립한다.
>     - $_nP_r = n \times (n-1) \times...\times(n-r+1)$
> - $_nP_n = n!$ 이라고 표기하며 Factorial이라 부른다.
>     - $n! = n \times(n-1)\times...\times2\times1$

> **단순하게 순열을 생성하는 방법**
> 
> - 예) {1, 2, 3}을 포함하는 모든 순열을 생성하는 함수
>     - 동일한 숫자가 포함되지 않았을 때, 각 자리 수 별로  loop를 이용해 아래와 같이 구현할 수 있다.
>         
>         ```c
>         arr = [1, 2, 3]
>         
>         for i1 in range(1, 4):
>             for i2 in range(1, 4):
>                 if i2 != i1:
>                     for i3 in range(1, 4):
>                         if i3 != i2 and i3 != i1:
>                             print(i1, i2, i3)
>         ```
>         

---

## 탐욕(Greedy) 알고리즘

> **탐욕(Greedy) 알고리즘**
> 
> - 탐욕 알고리즘은 최적해를 구하는 데 사용되는 근시안적인 방법
> - 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달한다.
> - 각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 최적이라는 보장은 없다.
> - 일반적으로, 머릿속에 떠오르는 생각을 검증 없이 바로 구현하면 Greedy 접근이 된다.

> **탐욕 알고리즘의 동작 과정**
> 
> 1. 해 선택 : 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분 해집합(Solution Set)에 추가한다.
> 2. 실행 가능성 검사 : 새로운 부분해 집합이 실행 가능한지를 확인한다.
>     
>     곧 문제의 제약 조건을 위반하지 않는지를 검사한다.
>     
> 3. 해 검사 : 새로운 부분해 집합이 문제의 해가 되는지를 확인한다.
>     
>     아직 전체 문제의 해가 완성되지 않았다면 1의 해 선택부터 다시 시작한다.
>     

> **탐욕 알고리즘의 예**
> 
> - 거스름돈 줄이기
>     - “어떻게 하면 손님에게 거스름돈으로 주는 지폐와 동전의 개수를 최소한으로 줄일 수 있을까?”
>     1. 해 선택 : 단위가 큰 동전으로만 거스름돈을 만들면 동전의 개수가 줄어드므로 현재 고를 수 있는 가장 단위가 큰 동전을 하나 골라 거스름돈에 추가한다.
>     2. 실행 가능성 검사 : 거스름돈이 손님에게 내 드려야 할 액수를 초과하는지 확인, 초과한다면 마지막에 추가한 동전을 거스름 돈에서 빼고, 1로 돌아감
>     3. 해 검사 : 거스름돈 문제의 해는 당연히 거스름돈이 손님에게 내드려야 하는 액수와 일치

> **탐욕 알고리즘 풀이**
> 
> - Baby-gin을 완전검색이 아닌 방법으로 풀어보자.
>     - 6개의 숫자는 6자리의 정수 값으로 입력된다.
>     - counts 배열의 각 원소를 체크하여 run과 triplet 및 baby-gin 여부를 판단한다.
>     
>     ```c
>     def is_baby_gin(num):
>         counts = [0 for i in range(0, 10)]
>         tmp = num
>         while tmp != 0:
>             counts[tmp % 10] += 1
>             tmp //= 10
>         for i in range(0, 10):
>             counts[i] %= 3
>         for i in range(0, 8):
>             min_v = min(counts[i:i+3])
>             counts[i] -= min_v
>             counts[i+1] -= min_v
>             counts[i+2] -= min_v
>         res = 0
>         for i in range(0, 8):
>             res += counts[i]
>         if res:
>             return False
>         else:
>             return True
>     ```
>     

---